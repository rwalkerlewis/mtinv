#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/stat.h>
#include <errno.h>
#include "../include/nrutil.h"     /** numerical recipes **/
#include "../include/mt.h"         /** global datatype and structure declarations **/

char progname[128];
long evid;

int main(int ac, char **av)
{

/************************/
/*** event info stuff ***/
/************************/
	EventInfo *ev;
	int ista, nsta;
	char evinfo_filename[128];

	int it;

/************************/
/*** Greens stuff     ***/
/************************/
        Greens **grn;
	/* FILE *fpg; */
	int nz,iz;
	float *z;

/****************/
/*** Solution ***/
/****************/
	Solution *sol;
	int iz_best;
	float bestfit, mechanism_size; 
	int npages;

/*******************/
/*** local stuff ***/
/*******************/
	/* int err; */
	int verbose=0;		/** verbose   1=yes 0=no default no verbose ***/
	int idump=0;
	int igmtmap=0;
	int mtdegfree=5;
	int forward=0;
	float ts0=0;
	int check_on_status_ok;
	int FixMyiz;
	float FixMyZ = -99;
	int Distance_Normalize = 0;
	float DistNormR0 = 1; /*** default is R0 = 1 km  in R/R0 ****/

	int ishift = 0;
	float cortol = 1.0;
	float maxtimeshift = 0; /*** about 1 cycle 25 < maxtimeshift < 5 sec ***/

	FixISOZ myfixisoz;

	int PltXcorLabel = 1;
	int idumpxy = 0;
	int iorientation = LANDSCAPE; /* orientation for gmtwf.csh */
	char orientation[12];

	int sqlite3_db_write = 0;
	int mysql_db_write = 0;
	int oracle_db_write = 0;
	
	int igmt5 = 1; /*** default true GMT version 5.x.x ***/
	int iuse_snr = 0;
	float MINSNR = 3;
	extern long evid;

/*******************/
/*** subroutines ***/
/*******************/

	/*** glib2inv_subs.c ***/
	EventInfo *glib2inv_get_input_parameters( char *filename, EventInfo *ev, int *n, int verbose );

	/*** writesacfile.c ***/
	void writesacfile( EventInfo *ev );

	/*** mtinv_subs.c ***/
	void mk_gmtplot_dir( char *output_pathname, int verbose );

	/*** mtinv_subs.c ***/
	void load_the_data( EventInfo *ev, int nsta, float ts0, int verbose );

	/*** mtinv_subs.c ***/
	float *load_greens( EventInfo *ev, Greens **grn, int nsta, int *nz_tmp, int verbose );

	/*** mtinv.c ***/
	void forward_calc(	
			EventInfo *ev,
			Greens **grn,
			int nsta,
			int nz,
			float *z,
			Solution *sol,
			int verbose,
			int idump, 
			int mtdegfree,
			int Distance_Normalize,
			float DistNormR0, 
			FixISOZ myfixisoz );

	/*** mtinv.c ***/
	void invert(	EventInfo *ev,
			Greens **grn,
			int nsta,
			int nz,
			Solution *sol,
			int verbose, 
			int idump,
			int mtdegfree,
			int Distance_Normalize,
			float DistNormR0,
			FixISOZ myfixisoz );

	/*** psplot.c ***/
	int psplot(	int nsta,
			int iz,
			char *filenbase,
			EventInfo *ev,
			Solution *sol,
			Greens **grn,
			int units,
			int verbose,
			int forward,
			int PltXcorLabel,
			int PS_Output_Screen );

	/*** check_depths.c ***/
	void check_iso_depth( FixISOZ *myfixisoz, float *z, int nz, int verbose );

	/*** check_depths.c ***/
	void check_depth( float FixMyZ, int *FixMyiz, float *z, int nz, int verbose );

	/*** mtinv_subs.c ***/
	void compute_synthetics( int is, int iz, EventInfo *ev, Greens **grn, Solution *sol, int mtdegfree );

	/*** mtinv_subs.c ***/
	void write_email_message( FILE *fp, int nsta, int iz, Solution *sol, EventInfo *ev, Greens **grn, int ifwd );

	/*** realtime_subs.c ***/
	void write_results2(
	        char *results_filename,
		Solution *sol,
		EventInfo *ev,
		Greens **grn,
		int iz,
		int nsta,
		int npages,
		int AutoAuth,
		int ishift,
		float cortol,
		float maxtimeshift,
		int iuse_snr,
		float minsnr, 	
		int igmt5, 
		int sqlite3_db_write,
		int mysql_db_write,
		int oracle_db_write );

	/*** mtinv_gmtsubs.c ***/
	void plot_z_vs_fit_gmt5( int iz, float *z, Solution *sol, EventInfo *ev );
	void plot_z_vs_fit_gmt4( int iz, float *z, Solution *sol, EventInfo *ev );

	/*** mtinv_gmtsubs.c ***/
	void plotmech_gmt5( int iz, Solution *sol, EventInfo *ev, float mechanism_size );
	void plotmech_gmt4( int iz, Solution *sol, EventInfo *ev, float mechanism_size );

	/*** mtinv_subs.c ***/
	void write_sol_rec( FILE *fp, int iz, int nsta, EventInfo *ev, Solution *sol, Greens **grn );

	/*** mtinv_gmtsubs.c ***/
	void make_map_gmt5( int iz, int nsta, EventInfo *ev, Solution *sol, Greens **g );
	void make_map_gmt4( int iz, int nsta, EventInfo *ev, Solution *sol, Greens **g );

	/*** crosscorrelation/cross_correlation.c ***/
	void xcorr(
		float *d, float *s, 
		int nt, float dt, int *ilag, float *tlag,
		float *xcorcoef, 
		float cortol, int verbose, int ishift );

	/*** find_best_shift.c ***/
	void find_best_shift( EventInfo *ev, float cortol, float maxtimeshift, float *time_shift_all );

	/*** mtinv_subs.c ***/
	void time_shift( EventInfo *ev, int nsta, int verbose );

	/*** mtinv_gmtsubs.c ***/
	void plot_results_gmt4( int iz, Solution *sol, EventInfo *ev );
	void plot_results_gmt5( int iz, Solution *sol, EventInfo *ev );

	/*** mtinv_subs.c ***/
	void calc_azi_gap_and_dmin( int iz, int nsta, EventInfo *ev, Solution *sol, Greens **g );

	/*** mtinv_subs.c ***/
	void write_mterror( FILE *fp, int nz, Solution *sol, EventInfo *ev, Greens **g );
	
	/*** sacextrema/sacextrema.c ***/
	void sac_absmax( float *x, int n, float *absmax );

	/*** mtinv.c ***/
	void Usage_Print( void );

	/*** mtinv_gmtsubs.c ***/
	void gmt4wfplot( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int iorientation, int verbose );
	void gmt5wfplot( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int iorientation, int verbose );

	/*** mtinv_subs.c ***/
	void dumpxy( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int verbose );

	/*** mtinv_gmtsubs.c ***/
	void wfplot2_gmt5( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int verbose );

/*** update dbsubs.c routines  ***/

	void db_sqlite3_create( void );
	void  mysql_db_create( void );
	void oracle_db_create( void );

	void db_sqlite3_write( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int AutoAuth, int verbose );
	void  db_mysql_write( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int AutoAuth, int verbose );
	void db_oracle_write( EventInfo *ev, Solution *sol, Greens **grn, int nsta, int iz, int AutoAuth, int verbose ); 
	int AutoAuth = 0;

/*** ../misc/getpar/ - libget.a(getarg.o) ***/

	int setpar(int,char **);
        int getpar();
        int mstpar();
        void endpar();

/*** shorten_path.c ***/
        char *shorten_path( char *pathname, char *filename );

/**************/
/*** output ***/
/**************/
	char pathname[128];
	char asc_file_name[128], ps_plot_filename[128];
	FILE *fpasc;
	
/*********************************************************************************************************************************************/
/********************************** START mtinv.c(main()) ************************************************************************************/
/*********************************************************************************************************************************************/

/********************/
/*** program name ***/
/********************/
	strcpy( pathname, av[0] );
	shorten_path( pathname, progname );

	if( verbose )
	{
	  fprintf( stdout, "%s: STDOUT: Version=%s ReleaseDate=%s exec full path=%s\n",
                progname, Version_Label, Version_Date, pathname );
	}

        fprintf( stderr, "%s: STDERR: Version=%s ReleaseDate=%s exec full path=%s\n",
                progname, Version_Label, Version_Date, pathname );

/*************/
/*** USAGE ***/
/*************/
	if( ac <= 1 )
	{
		Usage_Print();
	}

/*****************************************************/
/*** get the input parameters foreach each station ***/
/*****************************************************/
	setpar(ac,av);
	mstpar( "par", "s", &evinfo_filename );
	mstpar( "mtdegfree", "d", &mtdegfree );
	mstpar( "ts0", "f", &ts0 );
	getpar( "fwd", "b", &forward );
	getpar( "fixz", "f", &FixMyZ );
	getpar( "verbose", "b", &verbose );
	getpar( "dumpsac", "b", &idump );
	getpar( "gmtmap", "b", &igmtmap );

	getpar( "norm", "b", &Distance_Normalize );
	if( Distance_Normalize )
	{
		mstpar( "R0", "f", &DistNormR0 );
	}

	getpar( "PltXcorLabel", "b", &PltXcorLabel );
	myfixisoz.z = 0;
	getpar( "FixISOZ", "f", &(myfixisoz.z) );

	getpar( "shift", "b", &ishift );
	if(ishift) 
	{
		mstpar( "ctol", "f", &cortol );
		mstpar( "maxshift", "f", &maxtimeshift );
	}

	getpar( "use_snr", "b", &iuse_snr );
	if( iuse_snr )
	{
		mstpar( "minsnr", "f", &MINSNR );
	}

	getpar( "dumpxy", "b", &idumpxy );
	if( idumpxy ) 
	{
		getpar( "orientation", "s", &orientation );
		if( strcmp( orientation, "portrait" ) == 0 ) 
		{
			iorientation = PORTRAIT;
		}
		else if( strcmp( orientation, "landscape" ) == 0 ) 
		{
			iorientation = LANDSCAPE;
		}
		else
		{
		  fprintf( stdout, 
		    "%s: unknown orientation = %s(%d) (valid responses = portrait or landscale) default landscape\n",
			progname, orientation, iorientation );
		}
	}

	getpar(   "sqlite", "b", &sqlite3_db_write );
	getpar(  "sqlite3", "b", &sqlite3_db_write );

	getpar(    "mysql", "b", &mysql_db_write );
	getpar(   "oracle", "b", &oracle_db_write );
	getpar( "AutoAuth", "b", &AutoAuth );
	evid = -1;
	getpar( "evid", "d", &evid );
	getpar( "gmt5", "b", &igmt5 );
	endpar();

/*********************/
/**** START MAIN  ****/
/*********************/

	if(verbose)
	{
		fprintf(stderr, "%s: verbose ON\n", progname );
		fprintf(stdout, "%s: verbose ON\n", progname );
	}
	else
	{
		fprintf(stderr, "%s: verbose OFF\n", progname );
	}
	
	if(iuse_snr)
	{
		if(verbose)
		fprintf(stdout, "%s: iuse_snr ON minsnr=%g\n", progname, MINSNR );
                fprintf(stderr, "%s: iuse_snr ON minsnr=%g\n", progname, MINSNR );
	}
	else
	{
		if(verbose)
		fprintf(stdout, "%s: iuse_snr OFF\n", progname );
                fprintf(stderr, "%s: iuse_snr OFF\n", progname );
	}

	if(verbose)
	{
		if(mtdegfree==1)fprintf(stdout, "%s: mtdegfree=%d EXPLOSION\n", progname, mtdegfree );
                if(mtdegfree==5)fprintf(stdout, "%s: mtdegfree=%d DEVIATORIC\n", progname, mtdegfree );
                if(mtdegfree==6)fprintf(stdout, "%s: mtdegfree=%d FULL_MT\n", progname, mtdegfree );
	}

	if(mtdegfree==1)fprintf(stderr, "%s: mtdegfree=%d EXPLOSION\n", progname, mtdegfree );
	if(mtdegfree==5)fprintf(stderr, "%s: mtdegfree=%d DEVIATORIC\n", progname, mtdegfree );
	if(mtdegfree==6)fprintf(stderr, "%s: mtdegfree=%d FULL_MT\n", progname, mtdegfree );

	if( myfixisoz.z > 0 )
		myfixisoz.iswitch = 1;
	else
		myfixisoz.iswitch = 0;
	

	if( Distance_Normalize )
	{
		if(verbose)
		fprintf( stdout, "%s: Distance_Normalize is ON R0=%g km\n", progname, DistNormR0 );
		fprintf( stderr, "%s: Distance_Normalize is ON R0=%g km\n", progname, DistNormR0 );
	}
	else
	{
		if(verbose)
                fprintf( stdout, "%s: Distance_Normalize is OFF\n", progname );
                fprintf( stderr, "%s: Distance_Normalize is OFF\n", progname );
	}

	if( myfixisoz.iswitch )
	{
		if(verbose)
		fprintf( stdout, 
			"%s: FixISOZ z = %g iswitch= %d is ON\n", 
			progname, 
			myfixisoz.z, 
			myfixisoz.iswitch  );

		fprintf( stderr,
                        "%s: FixISOZ z = %g iswitch= %d is ON\n",
                        progname,
                        myfixisoz.z,
                        myfixisoz.iswitch  );
	}
	else
	{
		if(verbose)
		fprintf( stdout, "%s: FixISOZ=%d is OFF\n",
                        progname, myfixisoz.iswitch );
		fprintf( stderr, "%s: FixISOZ=%d is OFF\n", 
			progname, myfixisoz.iswitch );
	}

	if(ishift)
	{
		if(verbose)
		{
		  fprintf( stdout, 
		    "%s: Shiftng by max cross-correlation is ON cortol=%g maxtimeshift=%g\n", 
			progname, cortol, maxtimeshift );
		}
		fprintf( stderr, 
		  "%s: Shiftng by max cross-correlation is ON cortol=%g maxtimeshift=%g\n", 
			progname, cortol, maxtimeshift );
	}
	else
	{
		if(verbose)
                fprintf( stdout, "%s: Shiftng by max cross-correlation is OFF\n", progname );
                fprintf( stderr, "%s: Shiftng by max cross-correlation is OFF\n", progname );
	}


/******************************************/
/*** allocate memory for parameter list ***/
/******************************************/
	if( verbose ) 
	{
		fprintf( stdout, "%s: allocating memory for data and event information\n", 
			progname );
	}

	ev  = (EventInfo *)malloc(sizeof(EventInfo));
	ev  = (EventInfo *)glib2inv_get_input_parameters( evinfo_filename, ev, &nsta, verbose );

/********************************************/
/*** loop over stations and load the data ***/
/********************************************/
	if( verbose ) 
	{
		fprintf( stdout, "%s: mtinv(): reading data nsta=%d\n", progname, nsta );
	}

	fprintf( stderr, "%s: mtinv(): reading data nsta=%d\n", progname, nsta );

	load_the_data( ev, nsta, ts0, verbose );

	for( ista = 0 ; ista < nsta ; ista++ )
        {
		  fprintf( stdout, "%s: mtinv(): STDOUT: ista=%d nt=%d %d %d dt=%g %g %g\n", 
			progname, 
			ista, 
			ev[ista].ew.s.npts, 
			ev[ista].ns.s.npts, 
			ev[ista].z.s.npts,
			ev[ista].ew.s.delta,
			ev[ista].ns.s.delta,
			ev[ista].z.s.delta );

	/*** debug ***/
/****
	fprintf( stdout, "----------- DEBUG ista = %d sta = %s NS ------------------\n", ista, ev[ista].ns.s.kstnm );
		for( it = 0; it < ev[ista].ns.s.npts; it++ )
		{
			if( fabs( ev[ista].ns.data[it] ) > 1.0E-04 ) 
			  fprintf( stdout, "ista=%d it=%d ev[ista].ns.data[it]=%g\n",
				ista, it, ev[ista].ns.data[it] );
		}
	fprintf( stdout, "----------- DEBUG ista = %d sta = %s EW ------------------\n", ista, ev[ista].ew.s.kstnm );
		for( it = 0; it < ev[ista].ew.s.npts; it++ )
		{
			if( fabs( ev[ista].ew.data[it] ) > 1.0E-04 )
			  fprintf( stdout, "ista=%d it=%d ev[ista].ew.data[it]=%g\n",
				ista, it, ev[ista].ew.data[it] );
		}
	fprintf( stdout, "---------------------------------------------------------------\n" );
****/
		writesacfile( &ev[ista] );
        }

/******************************/
/*** load green's functions ***/
/******************************/

	if(verbose) printf( "%s: allocating memory for Green's function\n",
		progname );
	grn = (Greens **)malloc( nsta*sizeof(Greens *) );
	z = (float *)load_greens( ev, grn, nsta, &nz, verbose );

/*************************************/
/*** FixISOZ check depth set index ***/
/*************************************/
	
	if( myfixisoz.iswitch )
	{
		check_iso_depth( &myfixisoz, z, nz, verbose );
	}

/**************************************/
/*** check if fixing solution depth ***/
/*** iz_best get reset below        ***/
/**************************************/

	if( FixMyZ != -99 )
	{
		check_depth( FixMyZ, &FixMyiz, z, nz, verbose );
	}

/***********************************************************************************/
/*** turn off stations that have all three channels/components with SNR < MINSNR ***/
/*** turn off only if iused was already turned off/ do not override cases where  ***/
/*** iused == 0 or iused == -1                                                   ***/
/***********************************************************************************/

	if(verbose)
	{
	  fprintf( stdout, "%s: iuse_snr = %d minsnr = %g\n", 
		progname, iuse_snr, MINSNR );
	}

	if( iuse_snr )
	{
	  for( ista=0; ista<nsta; ista++ )
	  {
		if( ( ev[ista].z.P2P_snr  < MINSNR) && 
		    ( ev[ista].ns.P2P_snr < MINSNR) && 
		    ( ev[ista].ew.P2P_snr < MINSNR) &&
		    ( ev[ista].iused == 1 ) )
		{
			ev[ista].iused = 0;
		}
		/*** else iused < 1, leave alone ***/
	  }
	}

/*****************************************************/
/*** Error check if any any stations are turned on ***/
/*****************************************************/

	check_on_status_ok = 0;
	for( ista=0; ista<nsta; ista++ )
	{
		if( ev[ista].iused == 1 ) check_on_status_ok=1;
	}

	if(verbose)
	fprintf( stdout, "%s: check_on_status_ok=%d\n", progname, check_on_status_ok );

	if( !check_on_status_ok )
	{
		if(verbose)
		fprintf( stdout, 
		  "%s: ERROR! no stations turned on in the par file %s\n",
			progname, evinfo_filename );

		fprintf( stderr,
		  "%s: ERROR! no stations turned on in the par file %s\n",
                        progname, evinfo_filename );
		exit(-1);
	}

/*********************************/
/*** set the type of inversion ***/
/*********************************/

	sol = (Solution *)malloc(nz*sizeof(Solution));
	for( iz=0; iz<nz; iz++ )
	{
		if( mtdegfree == 1 )  sol[iz].mt_type = EXPLOSION;
		if( mtdegfree == 5 )  sol[iz].mt_type = DEVIATORIC;
		if( mtdegfree == 6 )  sol[iz].mt_type = FULL_MT;
	}

/****************************************************************/
/*** check to see if this is a forward or inverse calculation ***/
/****************************************************************/

	if( forward )
	{
		if( verbose )
			fprintf( stdout, "%s: calling forward calc mtdegfree=%d\n",
			  progname, mtdegfree );

		forward_calc(	ev,
				grn,
				nsta,
				nz,
				z,
				sol,
				verbose,
				idump,
				mtdegfree,
				Distance_Normalize,
				DistNormR0,
				myfixisoz );

		/*****************************/
		/*** what is the best fit  ***/
		/*****************************/
		iz_best = 0;
		bestfit = sol[0].total_fitness1;
		for( iz=0; iz<nz; iz++ )
		{
			if( ev[0].evdp == z[iz] )
			{
				if(verbose)
				{  
				  fprintf(stdout, "%s: mtinv.c: best iz=%d z=evdp=%g\n", 
					progname, iz, z[iz] );
				}
				iz_best = iz;
				bestfit = sol[iz].total_fitness1;
			}
		}
		if( FixMyZ != -99 ) iz_best = FixMyiz;
	}
	else /*** do inversion ***/
	{
		if( verbose ) fprintf( stdout, "%s: calling invert()\n", progname );
		fprintf( stderr, "%s: calling invert()\n", progname );

	/****************************/
	/*** calling inversion    ***/
	/****************************/

		invert(	ev,
			grn,
			nsta,
			nz,
			sol,
			verbose,
			idump, 
			mtdegfree,
			Distance_Normalize, 
			DistNormR0, 
			myfixisoz );
		
	/****************************/
	/*** what is the best fit ***/
	/****************************/

		iz_best = 0;
		bestfit = sol[0].total_fitness1;
		for( iz=0; iz<nz; iz++ )
		{
		  if(verbose)
		  {
		    fprintf( stdout, "%s: iz=%d z=%g ot=%g ts0=%g fit1[iz]=%g vred=%g ",
			progname, 
			iz, z[iz], ev[0].ot_shift, ev[0].ts0, 
			sol[iz].total_fitness1, sol[iz].var_red );
		    fprintf( stdout, "pdc=%g iz_best=%d fit1[iz_best]=%g fit2[iz]=%g fit2[best]=%g\n", 
			sol[iz].PDC, iz_best, sol[iz_best].total_fitness1,
			sol[iz].total_fitness2, sol[iz_best].total_fitness2 );
		    fflush(stdout);
		  }

		  fprintf( stderr, "%s: iz=%d z=%g ot=%g ts0=%g fit1[iz]=%g vred=%g ",
                        progname,
                        iz, z[iz], ev[0].ot_shift, ev[0].ts0,
                        sol[iz].total_fitness1, sol[iz].var_red );
		  fprintf( stderr, "pdc=%g iz_best=%d fit1[iz_best]=%g fit2[iz]=%g fit2[best]=%g\n",
                        sol[iz].PDC, iz_best, sol[iz_best].total_fitness1,
                        sol[iz].total_fitness2, sol[iz_best].total_fitness2 );

		  if( sol[iz].total_fitness1 > bestfit ) 
		  {
			bestfit = sol[iz].total_fitness1;
			iz_best = iz;
		  }
		}
		if( FixMyZ != -99 ) iz_best = FixMyiz;

		if(verbose)
		{
		  fprintf( stdout, "%s: iz_best=%d z=%g ot=%g ts0=%g VR=%.2f pdc=%.0f fit1=%.2f fit2=%.2f\n",
			progname, 
                        iz_best, 
			z[iz_best], 
			ev[0].ot_shift, 
			ev[0].ts0,
			sol[iz_best].var_red, 
                        sol[iz_best].PDC, 
			sol[iz_best].total_fitness1,
			sol[iz_best].total_fitness2 );
                   fflush(stdout);
		}

		fprintf( stderr, "%s: iz_best=%d z=%g ot=%g ts0=%g VR=%.2f pdc=%.0f fit1=%.2f fit2=%.2f\n",
                        progname,
                        iz_best,
                        z[iz_best],
                        ev[0].ot_shift,
                        ev[0].ts0,
                        sol[iz_best].var_red,
                        sol[iz_best].PDC,
                        sol[iz_best].total_fitness1,
                        sol[iz_best].total_fitness2 );


	} /*** end inversion or forward option ***/
	
/******************************************************************/
/*** write out a gmt shell script for each time shift and depth ***/
/******************************************************************/

	mechanism_size = 0.4;

	if( igmt5 )
	{
		if(verbose)
		{
			fprintf( stdout, "%s: mtinv(): calling plotmech_gmt5():\n", progname );
		}
		plotmech_gmt5( iz_best, sol, ev, mechanism_size );
	}
	else
	{
		if(verbose)
                {
                        fprintf( stdout, "%s: mtinv(): calling plotmech_gmt4():\n", progname );
                }
                plotmech_gmt4( iz_best, sol, ev, mechanism_size );
	}

/******************************************************************/
/*** write out for R. B. Herrmann mteig and mtdec input         ***/
/*** overwrites previous version of of mteig.in                 ***/
/******************************************************************/
/***
	fpasc = fopen( "mteig.in", "w" );
	fprintf( fpasc, "3\n" );
	fprintf( fpasc, "%g %g %g\n", 
		sol[iz_best].moment_tensor[1][1], sol[iz_best].moment_tensor[1][2], sol[iz_best].moment_tensor[1][3] );
	fprintf( fpasc, "%g %g %g\n", 
		sol[iz_best].moment_tensor[2][1], sol[iz_best].moment_tensor[2][2], sol[iz_best].moment_tensor[2][3] );
	fprintf( fpasc, "%g %g %g\n", 
		sol[iz_best].moment_tensor[3][1], sol[iz_best].moment_tensor[3][2], sol[iz_best].moment_tensor[3][3] );
	fclose(fpasc);

	if(verbose)
	 fprintf( stdout, "%s: mtinv(): wrote file mteig.in for Herrmann's mteig and mtdec apps\n", progname );
****/

/********************************************/
/*** write an output file with the errors ***/
/********************************************/

/*** no one uses mterror.out file anymore delete ***/
/***
	sprintf( asc_file_name, "mterror.out" );
	if( (fpasc=fopen( asc_file_name, "w" )) == NULL )
		fprintf( stdout, "cannot open file %s for writting\n", asc_file_name );
	if(verbose)
	  fprintf( stdout, "%s: mtinv(): calling write_mterror():\n", progname );
	write_mterror( fpasc, nz, sol, ev, grn );
	fclose(fpasc);
****/

/********************************************/
/*** make an ascii plot for fast email    ***/
/********************************************/

	if(verbose)
	  fprintf( stdout, "%s: mtinv(): calling calc_azi_gap_and_dmin():\n", progname );

	calc_azi_gap_and_dmin( iz_best, nsta, ev, sol, grn );

/***************************************************************************/
/*** write out MT solution results to a text file format for email       ***/
/***************************************************************************/

	sprintf( asc_file_name, "email_T%05.1fsec_Z%05.1fkm_.txt", 
			sol[iz_best].ot, grn[0][iz_best].evdp );
	if(verbose)
	{
		fprintf(stdout, "%s: mtinv.c: Writing Email Messages to %s\n", 
			progname, asc_file_name );
	}
	
	if( (fpasc=fopen( asc_file_name, "w" ) ) == NULL )
	{
		fprintf(stdout, "cannot open file for writting\n");
	}

	if(verbose)
	{
	  fprintf( stdout, "%s: mtinv(): calling write_email_message():\n", progname );
	}
	write_email_message( fpasc, nsta, iz_best, sol, ev, grn, forward );
	fclose(fpasc);

/***************************************************************************/
/*** write out an ascii text file of the MT results                      ***/
/*** this output file is used by GMT C-shell script for plotting results ***/
/***************************************************************************/

	if(verbose)
	{
		fprintf( stdout, "%s: mtinv.c: bestfit=%g iz=%d\n", 
			progname, bestfit, iz_best );	
	}
	sprintf( asc_file_name, "results.%d.out", mtdegfree );

	if( (fpasc=fopen( asc_file_name, "a" ) ) == NULL )
	{
		fprintf(stdout, "cannot open file for writting\n");
	}

	if(verbose)
		fprintf( stdout, "%s: mtinv(): calling write_sol_rec():\n", progname );
	write_sol_rec( fpasc, iz_best, nsta, ev, sol, grn );
	fclose(fpasc);

/*************************************/
/*** write out a gmt shell script ***/
/*************************************/

	if(igmt5)
	{
		if(verbose) 
		{
		  fprintf( stdout, "%s: mtinv(): calling plot_z_vs_fit_gmt5(): \n", 
			progname );
		}
		plot_z_vs_fit_gmt5( iz_best, z, sol, ev );
	}
	else
	{
		if(verbose)
                {
                  fprintf( stdout, "%s: mtinv(): calling plot_z_vs_fit_gmt4(): \n",
                        progname );
                }
                plot_z_vs_fit_gmt4( iz_best, z, sol, ev );
	}

/***************************************/
/*** compute synthetics for plotting ***/
/***************************************/

	if(verbose)
	{
	  fprintf( stdout, "%s: recalculate the synthetics for iz_best=%d\n",
		progname, iz_best );
	}

	for( ista=0; ista<nsta; ista++ )
	{
		ev[ista].syn_r.data = calloc( ev[ista].nt, sizeof(float) );
		ev[ista].syn_z.data = calloc( ev[ista].nt, sizeof(float) );
		ev[ista].syn_t.data = calloc( ev[ista].nt, sizeof(float) );

		if(verbose)
		{
		  fprintf( stdout, 
		    "%s: mtinv.c: calling compute_synthetics iz_best=%d ista=%d nt=%d dt=%g\n",
			progname, iz_best, ista, ev[ista].nt, ev[ista].dt );
		}

		compute_synthetics( ista, iz_best, ev, grn, sol, mtdegfree );
	}

/*******************************************************************************************/
/*** for each station do a cross correlation to find the lag time and correlation values ***/
/*******************************************************************************************/

	if(verbose)
	{
	  fprintf( stdout, 
	    "%s: mtinv.c: calling cross correlation for iz_best=%d cortol=%f maxshift=%f ishift=%d\n", 
		progname, iz_best, cortol, maxtimeshift, ishift );
	}

	for( ista=0; ista<nsta; ista++ )
	{

		/*** force ishift = 0 ***/
		xcorr( &(ev[ista].z.data[0]), &(ev[ista].syn_z.data[0]), ev[ista].nt, ev[ista].dt, 
			&(ev[ista].izlag), &(ev[ista].ztlag), &(ev[ista].zxcor), cortol, verbose, 0 );

		xcorr( &(ev[ista].ns.data[0]), &(ev[ista].syn_r.data[0]), ev[ista].nt, ev[ista].dt,
                        &(ev[ista].irlag), &(ev[ista].rtlag), &(ev[ista].rxcor), cortol, verbose, 0 );

		xcorr( &(ev[ista].ew.data[0]), &(ev[ista].syn_t.data[0]), ev[ista].nt, ev[ista].dt,
                        &(ev[ista].itlag), &(ev[ista].ttlag), &(ev[ista].txcor), cortol, verbose, 0 );

	/*** based on max cross correlation shift all data by same amount ***/
	
		if(ishift)
		{
		  find_best_shift( &(ev[ista]), cortol, maxtimeshift, &(ev[ista].time_shift_all) );
		}

		if(verbose)
		{
		  fprintf( stdout, "%s: %s.%s.%s: otshift=%g stashift=%g\n",
			progname, 
			ev[ista].ew.s.kstnm, 
			ev[ista].ew.s.knetwk,
			ev[ista].ew.s.kcmpnm, 
			ev[ista].ts0,
			ev[ista].time_shift_all );

		  fprintf( stdout, "%s: \t izlag=%3d ztlag=%5.2f zxcor=%.2f\n",
			progname, 
			ev[ista].izlag,
			ev[ista].ztlag,
			ev[ista].zxcor ); 
		
		  fprintf( stdout, "%s: \t irlag=%3d rtlag=%5.2f rxcor=%.2f\n", 
			progname, 
                        ev[ista].irlag,
			ev[ista].rtlag, 
			ev[ista].rxcor );

		  fprintf( stdout, "%s: \t itlag=%3d ttlag=%5.2f txcor=%.2f\n", 
			progname, 
                        ev[ista].itlag,
			ev[ista].ttlag,
			ev[ista].txcor );
		}

	} /*** loop over stations and cross correlate data/syn ***/

/*** do the time shift, and cross correlate again to update the plot ***/

	if(ishift)
	{
		if(verbose)
		{
		  fprintf( stdout, "%s: mtinv(): calling time_shift()\n", progname );
		}

		time_shift( ev, nsta, verbose );

		for( ista=0; ista<nsta; ista++ )
		{
		 /*** force ishift = 0 ***/
                 xcorr( &(ev[ista].z.data[0]), &(ev[ista].syn_z.data[0]), ev[ista].nt, ev[ista].dt,
                        &(ev[ista].izlag), &(ev[ista].ztlag), &(ev[ista].zxcor), cortol, verbose, 0 );
                                                                                                                                                                
                 xcorr( &(ev[ista].ns.data[0]), &(ev[ista].syn_r.data[0]), ev[ista].nt, ev[ista].dt,
                        &(ev[ista].irlag), &(ev[ista].rtlag), &(ev[ista].rxcor), cortol, verbose, 0 );
                                                                                                                                                                
                 xcorr( &(ev[ista].ew.data[0]), &(ev[ista].syn_t.data[0]), ev[ista].nt, ev[ista].dt,
                        &(ev[ista].itlag), &(ev[ista].ttlag), &(ev[ista].txcor), cortol, verbose, 0 );
		}
	}

/*************************************/
/*** Cgraphics PS library routines ***/
/*************************************/

	sprintf( ps_plot_filename, "plot_T%05.1fsec_Z%05.1fkm_", 
		sol[iz_best].ot, grn[0][iz_best].evdp );
	if(verbose)
	{
		fprintf( stdout, "%s: mtinv.c: mtinv(): Plotting Postscript Plot %s\n", 
			progname, ps_plot_filename );
		fprintf( stdout, "%s: mtinv.c: mtinv(): calling psplot()\n", progname );
	}

/*** debug ***/
/*
	for( ista = 0 ; ista < nsta ; ista++ )
	{
		writesacfile( &ev[ista] );
	}
*/

	npages = psplot( 
		nsta,
		iz_best,
		ps_plot_filename,
		ev,
		sol,
		grn,
		0,
		verbose,
		forward,
		PltXcorLabel,
		LANDSCAPE );

/*****************************************/
/*** write out results for mtbestfit.c ***/
/*** and for automt                    ***/
/*****************************************/

	write_results2(
		"automt.txt",
		sol,
		ev,
		grn,
		iz_best,
		nsta,
		npages,
		AutoAuth,
		ishift,
		cortol,
		maxtimeshift,
		iuse_snr,
                MINSNR,
		igmt5,
		sqlite3_db_write,
		mysql_db_write,
		oracle_db_write );	

/**********************/
/*** make a GMT map ***/
/**********************/

	if( igmtmap )	
	{
	  if( igmt5 )
	  {
	  	if(verbose)
	  	{
			fprintf(stdout, 
			  "%s: mtinv.c: mtinv(): calling make_map_gmt5(), making a GMT map for plotting\n",  
				progname );
		}
		make_map_gmt5( iz_best, nsta, ev, sol, grn );
	  }
	  else
	  {
		if(verbose)
                {
                        fprintf(stdout,
                          "%s: mtinv.c: mtinv(): calling make_map_gmt4(), making a GMT map for plotting\n",
                                progname );
                }
                make_map_gmt4( iz_best, nsta, ev, sol, grn );
	  }
	}

/*********************************************/
/*** plot origin time depth fit trade offs ***/
/*********************************************/

	if( igmt5 )
	{
		if(verbose)
		{
		  fprintf(stdout, "%s: mtinv.c: mtinv(): calling plot_results_gmt5()\n", 
			progname );
		}
		plot_results_gmt5( iz_best, sol, ev );
	}
	else
	{
		if(verbose)
		{
		  fprintf(stdout, "%s: mtinv.c: mtinv(): calling plot_results_gmt4()\n",
                        progname );
		}
		plot_results_gmt4( iz_best, sol, ev );
	}

/**************************************************************************/
/*** dump out the data and synthetics as ascii text files for GMT plots ***/
/**************************************************************************/

	if( idumpxy )
	{
		if(verbose)
		{
                  fprintf(stdout, "%s: mtinv.c: mtinv(): calling dumpxy()\n", progname );
		}

		dumpxy( ev, sol, grn, nsta, iz_best, verbose );

		if( igmt5 )
		{
		  if(verbose)
		  {
			fprintf(stdout, "%s: mtinv.c: mtinv(): calling gmt5wfplot()\n", progname );
		  }

		  /* gmt5wfplot( ev, sol, grn, nsta, iz_best, iorientation, verbose ); */

		  wfplot2_gmt5( ev, sol, grn, nsta, iz_best, verbose );
		}
		else
		{
		  if(verbose)
		  {
		    fprintf(stdout, "%s: mtinv.c: mtinv(): calling gmt4wfplot()\n", progname );
		  }
		  gmt4wfplot( ev, sol, grn, nsta, iz_best, iorientation, verbose );
		}
	}

	if( sqlite3_db_write )
	{
		if(verbose)
		  fprintf(stdout, "%s: mtinv.c: mtinv(): calling db_sqlite3_create()\n", progname );

		db_sqlite3_create();

		if(verbose)
		  fprintf(stdout, "%s: mtinv.c: mtinv(): calling db_sqlite3_write()\n", progname );

		db_sqlite3_write(  ev, sol, grn, nsta, iz_best, AutoAuth, verbose );
	}

	if( mysql_db_write )
	{
		if(verbose)
		  fprintf(stdout, "%s: mtinv.c: mtinv(): calling mysql_db_create()\n", progname );

		mysql_db_create();

		if(verbose)
                  fprintf(stdout, "%s: mtinv.c: mtinv(): calling db_write()\n", progname );

		db_mysql_write(  ev, sol, grn, nsta, iz_best, AutoAuth, verbose );
	}

	if( oracle_db_write )
	{
		if(verbose)
                  fprintf(stdout, "%s: mtinv.c: mtinv(): calling oracle_db_create()\n", progname );

		oracle_db_create();

		if(verbose)
                  fprintf(stdout, "%s: mtinv.c: mtinv(): calling db_oracle_write()\n", progname );

		db_oracle_write( ev, sol, grn, nsta, iz_best, AutoAuth, verbose );
	}

/*****************************/
/*** unallocate the memory ***/
/*****************************/
	if(verbose)
	{
	  fprintf(stdout, 
	    "%s: mtinv.c: mtinv(): Trying to free memory...", progname );
	}
/*
	free(sol);
	free(z);

	for( ista=0; ista<nsta; ista++ )
	{
		free( ev[ista].ew.data );
		free( ev[ista].ns.data );
		free( ev[ista].z.data );

		free( ev[ista].syn_t.data );
		free( ev[ista].syn_r.data );
		free( ev[ista].syn_z.data );
	}
	free(ev);
	free(grn);
*/
	if(verbose) fprintf(stdout, " Done.\n" );

	if(verbose)
	fprintf(stdout, "%s: mtinv.c: mtinv(): STDOUT: Program finished.  Bye-Bye!\n", progname );

        fprintf(stderr, "%s: mtinv.c: mtinv(): STDERR: Program finished.  Bye-Bye!\n", progname );

	exit(0);

} /*** end of mtinv.c ***/


/***************************/
/*** forward calculation ***/
/***************************/

void forward_calc( EventInfo *ev,
		Greens **grn,
		int nsta,
		int nz, float *z, 
		Solution *sol,
		int verbose,
		int idump,
		int mtdegfree, 
		int Distance_Normalize,
		float DistNormR0,
		FixISOZ myfixisoz )
{
	int i, j, rows, cols;
	float basemoment = 1.2445146117e+16;

	int ista, iz, myiz;
	int notfound = 1;
	float **mt;
	MomentTensor Ma, Mn;
	
	float **a_matrix;
	float *s_vector;
	float *x_vector;
	float *b_vector;
	
	float **matrix( int, int, int, int );
	float *vector( int, int );

	void set_moment_tensor( MomentTensor *, MomentTensor *, float *, int, int );
	void normalize_moment_tensor( MomentTensor *, MomentTensor *, int );
	void calc_deviatoric_moment( MomentTensor *, int );

	void sdr_to_mt( float **, float, float, float, float, int );
	float variance_reduction( float *, float *, int );
	float compute_l2norm_error( float *, float *, int );
	void demultiplex( Greens **, EventInfo *, int, float *, int );
	void mt2eig( MomentTensor, Solution *, int, int );
	void eig2iso( Solution *, int, int );
	void Eig2MajorDC( Solution *, int, int );
	void Eig2MinorDC( Solution *, int, int );

	void make_amatrix2( Greens **, EventInfo *, int, int, float **, float *, int, int, float, FixISOZ );

	void make_amatrix( Greens **, EventInfo *, int, int, float **, float *, int, int, float, FixISOZ );

	void matmul( int, float **, int, float *, int, float * );
	void grn2disp( Greens *, EventInfo *, int, int );
	void sac_minmax( float *, int, float *, float *, float * );

/*** initalize memory ***/
	cols = 6;
	mt = matrix( 0, cols+1, 0, cols+1 );
	x_vector = vector( 1, cols+1 );

/*** if event tag present in input file then compute synthetics ***/
	for( ista=0; ista<nsta; ista++ )
	{

		if(verbose)
		{
		  printf( "%s: ista=%d %s.%s z=%g str=%g dip=%g rak=%g Mw=%g mtdegfree=%d\n",
			progname,
			ista,
			ev[ista].stnm,
			ev[ista].net,
			ev[ista].my_z,
			ev[ista].str,
			ev[ista].dip,
			ev[ista].rak,
			ev[ista].Mw,
			mtdegfree );
		}

		for( iz=0; iz<nz; iz++ )
		{
			if( ev[ista].my_z == z[iz] && ev[ista].evdp == z[iz] )
			{
			  notfound = 0;
			  grn2disp( &(grn[ista][iz]), &ev[ista], verbose, mtdegfree );
			  myiz = iz;
			}
		}

		if(notfound)
		{
		  fprintf( stderr, "%s: ista=%d matching depth not found for station %s.%s ... looking for my_z=%g ",
			progname, 
			ista, 
			ev[ista].stnm,
			ev[ista].net,
			ev[ista].my_z );
		  for( iz=0; iz<nz; iz++ )
		  {
			fprintf( stderr, "\t iz=%d z=%18.7f\n", iz, z[iz] );
		  }
		  exit(0);
		}
		else
		{
		  if(verbose)
		    fprintf( stdout, "%s: ista=%d matching depth z=%g iz=%d found for station=%s.%s\n",
		      progname, ista, ev[ista].my_z, iz, ev[ista].stnm, ev[ista].net );
		}
	}
	ista = 0;
	iz = myiz;

	sdr_to_mt( mt, ev[ista].str, ev[ista].dip, ev[ista].rak, ev[ista].Mw, verbose );
	
	ev[ista].Mo = pow( 10.0, 1.5*( ev[ista].Mw + 10.73 ) );

	if( mtdegfree == 1 ) 
	{
		mt[1][2] = 0;
		mt[1][3] = 0;
		mt[2][1] = 0;
		mt[2][3] = 0;
		mt[3][1] = 0;
		mt[3][2] = 0;
		mt[1][1] = ev[ista].Mo/basemoment;
		mt[2][2] = ev[ista].Mo/basemoment;
		mt[3][3] = ev[ista].Mo/basemoment;
	}

	if( mtdegfree == 5 )
	{
		mt[3][3] = -( mt[1][1] + mt[2][2] );

	}

	sol[iz].moment_tensor[1][1] = mt[1][1];
	sol[iz].moment_tensor[1][2] = mt[1][2];
	sol[iz].moment_tensor[1][3] = mt[1][3];
	sol[iz].moment_tensor[2][1] = mt[2][1];
	sol[iz].moment_tensor[2][2] = mt[2][2];
	sol[iz].moment_tensor[2][3] = mt[2][3];
	sol[iz].moment_tensor[3][1] = mt[3][1];
	sol[iz].moment_tensor[3][2] = mt[3][2];
	sol[iz].moment_tensor[3][3] = mt[3][3];

/******************************************************************/
/*** form the moment tensor from solution vector x              ***/
/*** col1-Mxx, col2-Myy, col3-Mxy, col4-Mxz, col5-Myz, col6-Mzz ***/
/******************************************************************/
	x_vector[1] = mt[1][1];
	x_vector[2] = mt[2][2];
	x_vector[3] = mt[1][2];
	x_vector[4] = mt[1][3];
	x_vector[5] = mt[2][3];
	x_vector[6] = mt[3][3];

	set_moment_tensor( &Ma, &Mn, x_vector, mtdegfree, verbose );
	normalize_moment_tensor( &Ma, &Mn, verbose );

	sol[iz].dmoment = Ma.moment;
	sol[iz].mw      = Ma.Mw;
	sol[iz].exponent = Ma.expon;
	sol[iz].abcassa = Ma.abcassa;

	sol[iz].mrr = Mn.rr;
	sol[iz].mtt = Mn.tt;
	sol[iz].mff = Mn.ff;
	sol[iz].mrt = Mn.rt;
	sol[iz].mrf = Mn.rf;
	sol[iz].mtf = Mn.tf;

	sol[iz].mxx = Mn.xx;
	sol[iz].mxy = Mn.xy;
	sol[iz].mxz = Mn.xz;
	sol[iz].myy = Mn.yy;
	sol[iz].myz = Mn.yz;
	sol[iz].mzz = Mn.zz;

	if( verbose )
	{
          /***1     2    3      4      5      6          7      8      9    10   11  12    13  ***/
	  printf( 
	    "%s: iz=%d z=%g Mo=%6.2e Mw=%5.2f Mo=%5.2f x10^ %2d Mij=%.2f %.2f %.2f %.2f %.2f %.2f\n",
		progname,         	/* 1 */
		iz, 			/* 2 */
		grn[0][iz].evdp,        /* 3 */
		sol[iz].dmoment,        /* 4 */
		sol[iz].mw,		/* 5 */
		sol[iz].abcassa, 	/* 6 */
		sol[iz].exponent, 	/* 7 */
		sol[iz].mrr, 		/* 8 */
		sol[iz].mtt,		/* 9 */
		sol[iz].mff, 		/* 10 */
		sol[iz].mrt, 		/* 11 */
		sol[iz].mrf, 		/* 12 */
		sol[iz].mtf 		/* 13 */
		);
	}

/*** calculate the eigenvalues from the moment tensor ***/
	mt2eig( Mn, sol, iz, verbose );
	eig2iso( sol, iz, verbose );
	Eig2MajorDC( sol, iz, verbose );
	Eig2MinorDC( sol, iz, verbose );
	
/*** initialize the a matrix ***/
	if( verbose )
	{
		fprintf(stdout, "%s: initalizing matrix for forward calculation nsta=%d iz=%d\n",
			progname, nsta, iz );
	}
	rows = 1;
	for( ista=0; ista<nsta; ista++ )
	{
		if( ev[ista].iused == 1 )
		{
			rows += 3 * grn[ista][iz].nt;
		}
	}
	if(verbose)fprintf( stdout, "rows=%d cols=%d\n", rows, cols );

	a_matrix = matrix( 0, rows+1, 0, cols+1 );
	s_vector = vector( 0, rows+1 );
	b_vector = vector( 0, rows+1 );

	for( j=1; j<=cols; j++ )
	{
		for( i=1; i<=rows; i++ )
		{
			a_matrix[i][j] = 0;
		}
	}
	for( i=1; i<=rows; i++ )
	{
		s_vector[i] = 0;
		b_vector[i] = 0;
	}
	
	if(verbose)
	{
		for( i=1; i<=6; i++ )
		{
			printf(" x(%d)=%g\n", i, x_vector[i] );
		}
		printf("\n");
	}

/****************************************************/
/*** make the A matrix do the forward calculation ***/
/*** then compute the variance reduction          ***/
/****************************************************/

	make_amatrix( grn, ev, nsta, iz, a_matrix, b_vector, mtdegfree, Distance_Normalize, DistNormR0, myfixisoz );

	matmul( 0, a_matrix, cols, x_vector, rows, s_vector );

	sol[iz].var_red = variance_reduction( b_vector, s_vector, rows );
	if(verbose)
		printf( "%s: iz=%d %%VRED=%g\n", progname, iz, sol[iz].var_red );

	sol[iz].l2norm_error = compute_l2norm_error( b_vector, s_vector, rows );

	if(verbose)
	  fprintf(stdout, "%s: iz=%d %%L2NORM=%g L2NORM/(NPTS-1)=%g NPTS=%d\n", 
		progname, iz, sol[iz].l2norm_error,
		sol[iz].l2norm_error/(rows-1), rows );

	sol[iz].total_fitness1 = sol[iz].var_red;
	sol[iz].total_fitness2 = sol[iz].var_red;

/*** get the solution from the first station ***/
	sol[iz].evlo = ev[0].evlo;
	sol[iz].evla = ev[0].evla;
	sol[iz].evdp = ev[0].evdp;
	sol[iz].ot   = ev[0].ot_shift;

	if(verbose) 
	{
	  fprintf( stdout, "%s: freeing memory inside forward_calc()\n",
		progname );
	}

	free_matrix( a_matrix, 0, rows+1, 0, cols+1 );
	free_vector( x_vector, 0, cols+1 );
	free_vector( s_vector, 0, rows+1 );
	free_vector( b_vector, 0, rows+1 );

	if(verbose)printf("leaving forward calculation\n");
}

/*******************************************************/
/*** this subroutine does the inversion by looping   ***/
/*** over all the greens functions in the library    ***/
/*******************************************************/

void invert(	
	EventInfo *ev,
	Greens **grn,
	int nsta,
	int nz,
	Solution *sol, 
	int verbose,
	int idump,
	int mtdegfree,
	int Distance_Normalize,
	float DistNormR0, 
	FixISOZ myfixisoz )
{
	int ista, iz;
	char sac_file_name[128];
	float wmax, wmin;
	MomentTensor Ma, Mn;

	void sac_absmax( float *, int, float * );

/*********************************************************/
/*** cols = 6 colums of symetic moment tensor elements ***/
/*********************************************************/

	int i, j, rows, cols;

	float **a_matrix;   /*** A matrux with dimensions a[1..rows][1..cols] ***/
	float **u_matrix;   /*** temp space               u[1..rows][1..cols] ***/
	float **v_matrix;   /*** temp space               v[1..cols][1..cols] ***/
	float *w_vector;    /*** temp space               w[1..cols]          ***/
	float *b_vector;    /*** data                     b[1..rows]          ***/
	float *s_vector;    /*** synthetic                s[1..rows]          ***/
	float *x_vector;    /*** solution (mom ten)       x[1..cols]          ***/
	float *e_vector;    /*** error vector             e[1..cols]          ***/
	float **cv_matrix;  /*** covariance matrix       cv[1..cols][1..cols] ***/
	
	float **matrix( int, int, int, int );
	float *vector( int, int );

	float variance_reduction( float *, float *, int );
	float compute_l2norm_error( float *, float *, int );
	void demultiplex( Greens **, EventInfo *, int, float *, int );

	void set_moment_tensor( MomentTensor *, MomentTensor *, float *, int, int );
	void normalize_moment_tensor( MomentTensor *, MomentTensor *, int );
	void calc_deviatoric_moment( MomentTensor *, int );
	
	void eig2lune_4mtinv( Solution *, int iz, int verbose );
	void mt2eig( MomentTensor, Solution *, int, int );
	void eig2iso( Solution *, int, int );
	void Eig2MajorDC( Solution *, int, int );
	void Eig2MinorDC( Solution *, int, int );

	void make_amatrix2( Greens **, EventInfo *, int, int, float **, float *, int, int, float, FixISOZ );

	void make_amatrix( Greens **, EventInfo *, int, int, float **, float *, int, int, float, FixISOZ );

	/*** mtinv_subs.c ***/
	void write_gmt_xy_values( Solution *sol,
				  EventInfo *ev,
        			  Greens **grn, 
				  int iz, 
				  int nsta, 
				  int verbose );

	void write_sac_file( char *, Sac_File *, int );
	
	void svbksb( float **, float *, float **, int, int, float *, float * );
	void svdcmp( float **, int, int, float *, float ** );
	void svdvar( float **, int, float *, float ** );

	float mean( float *, int );
	float variance( float *, int, float );
	float root_mean_ssquare_variance( float *, float *, int );
	void diag( int, float **, float * );
	void matmul( int, float **, int, float *, int, float * );
	void sac_minmax( float *, int, float *, float *, float * );
	
/************************************************************************************************/
/*** LOOP OVER DEPTH ****************************************************************************/
/************************************************************************************************/
	cols = 6;

	for( iz = 0 ; iz < nz ; iz++ )
	{

	/*************************************************/
	/*** get the total data length rows the matrix ***/
	/*************************************************/

		rows = 1;

		for(ista=0; ista<nsta; ista++ )
		{
			if( ev[ista].iused == 1 )
			{
				rows += 3*grn[ista][iz].nt;
			}
		}

		if( verbose ) 
		{
		  fprintf( stdout, "%s: A matrix: rows=%d cols=%d\n", progname, rows, cols);
		}

	/*************************/
	/*** Allocating memory ***/
	/*************************/
		if(verbose)
		{
		  fprintf( stdout, "%s: allocating memory for iz=%d\n", progname, iz );
		}

		if(verbose)
		{
		  fprintf( stdout, 
		    "%s: Allocating memory for a_matrix rows=%d cols=%d\n", progname, rows, cols );
		}

		a_matrix  = matrix( 0, rows+1, 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for u_matrix\n", progname );
		u_matrix  = matrix( 0, rows+1, 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for v_matrix\n", progname );
		v_matrix  = matrix( 0, cols+1, 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for cv_matrix\n", progname );
		cv_matrix = matrix( 0, cols+1, 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for w_vector\n", progname );
		w_vector = vector( 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for e_vector\n", progname );
		e_vector = vector( 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for x_vector\n", progname );
		x_vector = vector( 0, cols+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for b_vector\n", progname );
		b_vector = vector( 0, rows+1 );

		if(verbose)fprintf(stdout, "%s: Allocating memory for s_vector\n", progname );
		s_vector = vector( 0, rows+1 );
		
	/********************************/
	/***** initialize memory ********/
	/********************************/

		for( j=1; j<=cols; j++ )
		{
			for( i=1; i<=rows; i++ )
			{
				u_matrix[i][j] = 0;
				a_matrix[i][j] = 0;
			}
			w_vector[j] = 0;
			e_vector[j] = 0;
			x_vector[j] = 0;
		}

		for( j=1; j<=cols; j++ )
		{
			for( i=1; i<=cols; i++ )
			{
				cv_matrix[i][j] = 0;	
				v_matrix[i][j]  = 0;
			}
		}

		for( i=1; i<=rows; i++ )
		{
			b_vector[i] = 0;
			s_vector[i] = 0;
		}

	/*********************************************************/
	/*** set up the A matrix and data vector for inversion ***/
	/*********************************************************/

		make_amatrix( grn, ev, nsta, iz, a_matrix, b_vector, mtdegfree, Distance_Normalize, DistNormR0, myfixisoz );

	/***************************************/
	/*** copy A matrix into the U matrix ***/
	/***************************************/

		for( j=1; j<=cols; j++ )
		{
			for( i=1; i<=rows; i++ )
			{
				u_matrix[i][j] = a_matrix[i][j];	
			}
		}

	/******************************/
	/***** do the inversion *******/
	/******************************/

		if( verbose )
		{
		  fprintf( stdout, "%s: inverting... calling svdcmp() rows=%d cols=%d\n", 
			progname, rows, cols );
		}

		svdcmp( u_matrix, rows, cols, w_vector, v_matrix );

	/********************************************************************************************/
	/*** this is where we set the threshold for singular values allowed to be nonzero.        ***/
	/*** The constant is typical but not universal. experiment with values other than 1.0E-06 ***/
	/*** this will be the maximum singular value obtained                                     ***/
	/********************************************************************************************/

		wmax = 0;
		for( j=1; j<=cols; j++)
		{
			if( w_vector[j] > wmax) wmax=w_vector[j];
		}

		wmin = wmax * 1.0E-5;
		for( j=1; j<=cols; j++)
		{
			if( w_vector[j] < wmin ) w_vector[j]=0.0;
		}

		if( verbose )
		{
		  fprintf( stdout, "%s: inverting... calling svbksb() rows=%d cols=%d\n", 
			progname, rows, cols );
		}

		svbksb( u_matrix, w_vector, v_matrix, rows, cols, b_vector, x_vector );

	/****************************************************/
	/*** multiply solution x vector with a matrix or  ***/
	/*** greens function matrix to get the s vector   ***/
	/*** or synthetics vector then....                ***/
	/*** compute the variance reduction and           ***/
	/*** l2_norm error                                ***/
	/****************************************************/

		matmul( 0, a_matrix, cols, x_vector, rows, s_vector );

		sol[iz].var_red = variance_reduction( b_vector, s_vector, rows );

		if(verbose) 
		{
			fprintf( stdout, "%s: iz=%d %%VRED=%g\n", 
				progname, iz, sol[iz].var_red );
		}

		sol[iz].l2norm_error = compute_l2norm_error( b_vector, s_vector, rows );

	/****************************************************/
	/*** this is the right one ***/
	/****************************************************/

		if(verbose)
		{
		  fprintf(stdout, "%s: iz=%d z=%g z=%g %%L2NORM=%g L2NORM/(NPTS-1)=%g NPTS=%d\n",
                     progname, iz, 
			sol[iz].evdp, 
			grn[0][iz].evdp,
			sol[iz].l2norm_error,
                     sol[iz].l2norm_error/(rows-1), rows );
		}

	/****************************************************/
	/*** calculate the covariance matrix              ***/
	/*** default is sigma = 1                         ***/
	/*** get sigma from RMS preevent noise ? level    ***/
	/*** error is 1.96 * sqrt( diag(CV_matrix) )      ***/
	/****************************************************/

		svdvar( v_matrix, cols, w_vector, cv_matrix );

	/******************************************************************/
	/*** form the moment tensor from solution vector x              ***/
	/*** col1-Mxx, col2-Myy, col3-Mxy, col4-Mxz, col5-Myz, col6-Mzz ***/
	/******************************************************************/
		
		sol[iz].moment_tensor[1][1] = x_vector[1]; /* Mxx */
		sol[iz].moment_tensor[2][2] = x_vector[2]; /* Myy */
		sol[iz].moment_tensor[1][2] = x_vector[3]; /* Mxy */
		sol[iz].moment_tensor[1][3] = x_vector[4]; /* Mxz */
		sol[iz].moment_tensor[2][3] = x_vector[5]; /* Myz */
		sol[iz].moment_tensor[3][3] = x_vector[6]; /* Mzz */
		sol[iz].moment_tensor[2][1] = x_vector[3]; /* Myx */
		sol[iz].moment_tensor[3][1] = x_vector[4]; /* Mzx */
		sol[iz].moment_tensor[3][2] = x_vector[5]; /* Mzy */

		if( mtdegfree == 5 ) 
		{
			sol[iz].moment_tensor[3][3] = -(x_vector[1] + x_vector[2]);
		}
	
		if(verbose)
		{
			fprintf( stdout, "%s: Normalizing the seismic moment tensor\n",
				progname );
		}

		set_moment_tensor( &Ma, &Mn, x_vector, mtdegfree, verbose );

		normalize_moment_tensor( &Ma, &Mn, verbose );
	
	/*** set the solution data structure ***/

		sol[iz].dmoment  = Ma.moment;
		sol[iz].mw       = Ma.Mw;
		sol[iz].exponent = Ma.expon;
		sol[iz].abcassa  = Ma.abcassa;
 
		sol[iz].mrr = Mn.rr;
        	sol[iz].mtt = Mn.tt;
		sol[iz].mff = Mn.ff;
		sol[iz].mrt = Mn.rt;
		sol[iz].mrf = Mn.rf;
		sol[iz].mtf = Mn.tf;
 
		sol[iz].mxx = Mn.xx;
		sol[iz].mxy = Mn.xy;
		sol[iz].mxz = Mn.xz;
		sol[iz].myy = Mn.yy;
		sol[iz].myz = Mn.yz;
		sol[iz].mzz = Mn.zz;

		if( idump )
		{
		  for( ista = 0; ista < nsta; ista++ )
		  {
			grn[ista][iz].tra = calloc( grn[ista][iz].nt, sizeof(float) );
			grn[ista][iz].rad = calloc( grn[ista][iz].nt, sizeof(float) );
			grn[ista][iz].ver = calloc( grn[ista][iz].nt, sizeof(float) );
			ev[ista].syn_r.data = calloc( ev[ista].ns.s.npts, sizeof(float) );
			ev[ista].syn_t.data = calloc( ev[ista].ew.s.npts, sizeof(float) );
			ev[ista].syn_z.data = calloc( ev[ista].z.s.npts,  sizeof(float) );
		  }
		  
		  if(verbose) 
		  {
			fprintf( stdout, "%s: calling demultiplex\n", progname );
		  }

		  demultiplex( grn, ev, iz, s_vector, nsta );

		  for( ista=0; ista<nsta; ista++ )
		  {
			sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.r.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
				ev[ista].syn_r.s = ev[ista].ns.s;
			sac_minmax( ev[ista].syn_r.data, ev[ista].syn_r.s.npts, 
				&(ev[ista].syn_r.s.depmax), &(ev[ista].syn_r.s.depmin), 
				&(ev[ista].syn_r.s.depmen) );
			write_sac_file( sac_file_name, &(ev[ista].syn_r), verbose );

			sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.z.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
			ev[ista].syn_z.s = ev[ista].z.s;
			sac_minmax( ev[ista].syn_z.data, ev[ista].syn_z.s.npts,
				&(ev[ista].syn_z.s.depmax), &(ev[ista].syn_z.s.depmin), 
				&(ev[ista].syn_z.s.depmen) );
			write_sac_file( sac_file_name, &(ev[ista].syn_z), verbose );

			sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.t.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
			ev[ista].syn_t.s = ev[ista].ew.s;
			sac_minmax( ev[ista].syn_t.data, ev[ista].syn_t.s.npts, 
				&(ev[ista].syn_t.s.depmax), &(ev[ista].syn_t.s.depmin), 
				&(ev[ista].syn_t.s.depmen) );
			write_sac_file( sac_file_name, &(ev[ista].syn_t), verbose );

			sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.r.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
			write_sac_file( sac_file_name, &(ev[ista].ns), verbose );

			sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.z.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
			write_sac_file( sac_file_name, &(ev[ista].z), verbose );

			sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.t.sac", 
				ev[ista].stnm, ev[ista].net, iz, ista );
			write_sac_file( sac_file_name, &(ev[ista].ew), verbose );
		  }

		  for( ista=0; ista<nsta; ista++ )
		  {
			free( ev[ista].syn_r.data );
			free( ev[ista].syn_r.data );
			free( ev[ista].syn_r.data );
			free( grn[ista][iz].rad );
			free( grn[ista][iz].tra );
			free( grn[ista][iz].ver );
		  }

		} /*** if idump ***/

	/************************************************************************/
	/*** eigenvalue analysis on moment tensor to get PDC and str/dip/rak  ***/
	/*** for both nodal planes and T- P- and N-axis.  Clone moment tensor ***/
	/*** so not to change the values by the next two routines.  Find      ***/
	/*** eigenvalues and eigenvectors by decomposing Mij using eigenvalue ***/
	/*** analysis                                                         ***/
	/************************************************************************/

		mt2eig( Mn, sol, iz, verbose );
		eig2iso( sol, iz, verbose );
		Eig2MajorDC( sol, iz, verbose );
		Eig2MinorDC( sol, iz, verbose );
		eig2lune_4mtinv( sol, iz, verbose );

	/**********************************/
	/***    output for GMT plots	***/
	/**********************************/
		sol[iz].total_fitness1 = 0;
		sol[iz].total_fitness2 = 0;

		if( mtdegfree == 1 || mtdegfree == 6 )
		{
			sol[iz].total_fitness1 = sol[iz].var_red;
			sol[iz].total_fitness2 = sol[iz].var_red;
		}
		else if( mtdegfree == 5 )
		{
		   sol[iz].total_fitness1 = 
			sol[iz].var_red / ( 101.0 - sol[iz].PDC );

		   sol[iz].total_fitness2 = 
			18 + sol[iz].var_red / ( 9 + (100-sol[iz].PDC) );

		  if( sol[iz].total_fitness2 > 35 ) sol[iz].total_fitness2 = 35;
		  if( sol[iz].total_fitness2 < 18 ) sol[iz].total_fitness2 = 18;
		}
		sol[iz].evlo = ev[0].evlo;
		sol[iz].evla = ev[0].evla;
		sol[iz].evdp = ev[0].evdp;
		sol[iz].ot   = ev[0].ot_shift;

	/******************************************************************/
	/*** write the output to GMT files for plotting in plotmech.csh ***/
	/******************************************************************/

		fprintf( stderr, "%s: mtinv_subs.c: invert(): calling write_gmt_xy_values(): iz=%d nsta=%d...", 
			progname, iz, nsta );

		write_gmt_xy_values( sol, ev, grn, iz, nsta, verbose );

		fprintf( stderr, "done\n" );

	/****************************/
	/*** free memory clean up ***/
	/****************************/

		if( verbose ) 
		{
		  fprintf(stdout, 
			"%s: freeing memory inside invert\n\trows=%d\n\tcols=%d\n\n", 
				progname, rows, cols );
		}

/*
		if(verbose) fprintf(stdout, "%s: freeing memory for a_matrix\n", progname);
		free_matrix( a_matrix, 0, rows+1, 0, cols+1 );
*/
		if(verbose) fprintf(stdout, "%s: freeing memory for u_matrix\n", progname); 
		free_matrix( u_matrix, 0, rows+1, 0, cols+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for v_matrix\n", progname); 
		free_matrix( v_matrix, 0, cols+1, 0, cols+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for cv_matrix\n", progname);
		free_matrix( cv_matrix, 0, cols+1, 0, cols+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for x_vector\n", progname); 
		free_vector( x_vector, 0, cols+1 );

                if(verbose) fprintf(stdout, "%s: freeing memory for s_vector\n", progname); 
		free_vector( s_vector, 0, rows+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for w_vector\n", progname); 
		free_vector( w_vector, 0, cols+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for b_vector\n", progname); 
		free_vector( b_vector, 0, rows+1 );

		if(verbose) fprintf(stdout, "%s: freeing memory for e_vector\n", progname); 
		free_vector( e_vector, 0, cols+1 );

		if(verbose) fprintf( stdout, "%s: done loop iz=%d\n", progname, iz );

	}  /*** iz ***/

	if(verbose)
	{
	 fprintf( stdout, "%s: Exiting from invert()\n", progname );
	 fflush(stderr);
	 fflush(stdout);
	}
}

void Usage_Print()
{
	fprintf( stderr, "\nUSAGE: %s par= mtdegfree=(1,5,6)\n", progname );
	fprintf( stderr, "\t [no]verbose [no]dumpsac [no]fwd [no]gmtmap\n" );
	fprintf( stderr, "\t ts0=[0] fixz=[-99] [no]norm [no]shift ctol=[1] FixISOZ=[-99]\n" );

	fprintf( stderr, "\nREQUIRED PARAMETERS:\n" );
 	fprintf( stderr, "\t par=(glib2inv.par) station parameter file\n" );
	fprintf( stderr, "\t mtdegfree=(1,5,6) 1=Isotropic MT, 5=Deviatoric MT, 6=Full MT\n" );

	fprintf( stderr, "\n OPTIONAL PARAMETERSL [DEFAULTS]\n" );
	fprintf( stderr, "\t ts0=[0]       Origin Time Shift Default is [0]\n" );
	fprintf( stderr, "\t fixz=[-99]    fix the depth Default is [-99] which turns off option\n" );
	fprintf( stderr, "\t [no]verbose   give verbose print to stdout. Default is off.\n" );
	fprintf( stderr, "\t [no]gmtmap    make a C-shell GMT script to plot a map of stations and solution, Default is off.\n" );
	fprintf( stderr, "\t [no]dumpsac   write out data and synthetics as SAC files. default is off\n" );
	fprintf( stderr, "\t [no]fwd       do forward calculation using input from glib2inv.par. default is off\n" );

	fprintf( stderr, "\t [no]norm     distance normalization default is off\n" );
	fprintf( stderr, "\t R0=1.0       normalize Green functions to distance of R/R0 default is R=1 km required if norm is set\n" );

	fprintf( stderr, "\t [no]shift    shift the data automatically by cross correlation peak. default is off\n" );
	fprintf( stderr, "\t ctol=[0.6]  Correlation coefficient tolerance to shift the data when coef > ctol. defaut is off\n" );
	fprintf( stderr, "\t maxshift=   Maximum time in seconds a shift is allowed. default off\n" );

	fprintf( stderr, "\t FixISOZ=     fix the depth of the rex and zex Green's function.  Default is off\n" );
	fprintf( stderr, "\t [no]PltXcorLabel  Plot the time lag shift and cross correlation as a label in the PostScript plot [Default is on\n" );

	fprintf( stderr, "\t [no]use_snr    use peak-to-peak amplitude based Signal-Noise Ratio to make stations non-defining in inversion [default off]\n" );
	fprintf( stderr, "\t minsnr=3       minimum snr threshold.  all 3-components must be less than minsnr to set non-defining in inversion [default 3]\n" );
	fprintf( stderr, "\t               use_snr and minsnr only applies to stations that are defining and does not override users settings \n" );

	fprintf( stderr, "\t [no]dumpxy     write out (x,y) ascii text files for the data and synthetics for GMT plots [Default is off]\n" );
	fprintf( stderr, "\t\t  includes GMT C-shell script (gmtwf.csh) which generates pages of postscripts plots\n" );

	fprintf( stderr, "\t[no]mysql   write out mysql source scripts (create.sql,insert.sql) based on the NNSA custom schema [Default is off]\n" );
	fprintf( stderr, "\t[no]oracle  write out oracle scripts (create.sql,insert.sql) based on the NNSA custom schema [Default is off]\n" );

	fprintf( stderr, "\t[no]gmt5    C-shell scripts using GMT plotting output version 5.x.x else version 4.x.x [default on]\n" );
	fprintf( stderr, "\n\n" );
}
