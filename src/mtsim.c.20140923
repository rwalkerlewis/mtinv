#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/stat.h>
#include <errno.h>
#include "../include/nrutil.h"     /** numerical recipes **/
#include "../include/mt.h"         /** global datatype and structure declarations **/

char progname[128];

int main(int ac, char **av)
{

/************************/
/*** event info stuff ***/
/************************/
	EventInfo *ev;
	int ista, nsta;
	char evinfo_filename[128];

/************************/
/*** Greens stuff     ***/
/************************/
        Greens **grn;
	int nz,iz;
	float *z;

/****************/
/*** Solution ***/
/****************/
	Solution *sol;
	int iz_best;
	float bestfit, mechanism_size; 
	char output_pathname[256];

/*******************/
/*** local stuff ***/
/*******************/
	int verbose=0;		/** verbose   1=yes 0=no default no verbose ***/
	int mtdegfree=5;
	int forward=0;
	float ts0=0;
	int check_on_status_ok;
	int FixMyiz;
	float FixMyZ = -99;
	int Distance_Normalize = 0;
	int ishift = 0;
	float cortol = 1.0;
	FixISOZ myfixisoz;
	int PltXcorLabel = 1;

/**************/
/*** output ***/
/**************/
        char asc_file_name[128], ps_plot_filename[128];
        FILE *fpasc;

	int Nmodels;     	/*** number of bootstrap resamples           ***/
	float *res;       	/*** residual vector from best fit inversion ***/
	float *best_b_vector;	/*** synthetics from best fit inversion to   ***/
				/*** be combined with bootstrap residuals to ***/
				/*** generate new data vector populations    ***/
	int nres;		/*** number of points in res vector length   ***/
	/*** subroutine to calculate the number of rows in A matrix          ***/
	int size_A_matrix( EventInfo *, Greens **, int, int );
	
/*****************************/
/*** subroutine prototypes ***/
/*****************************/

	int setpar(int,char **);
	int getpar();
	int mstpar();
	void endpar();
	
	EventInfo *glib2inv_get_input_parameters( char *, EventInfo *, int *, int );
	void mk_gmtplot_dir( char *, int );
	void load_the_data( EventInfo *, int, float, int );
	float *load_greens( EventInfo *, Greens **, int, int *, int );

	void invert0( EventInfo *ev, Greens **grn, int nsta, int nz, int iz_best,
		Solution *sol, float *res, float *best_b_vector, int *nres, 
		int verbose, int mtdegfree, int Distance_Normalize, 
		FixISOZ myfixisoz, char *output_pathname );

	void invert_sim( EventInfo *ev, Greens **grn, int nsta, int iz_best, 
		Solution *sol, float *res, float *best_b_vector, int verbose, 
		int mtdegfree, int Distance_Normalize, FixISOZ myfixisoz, 
		int Nmodels, char *output_pathname );

	void psplot( int, int, char *, EventInfo *, Solution *, Greens **, 
		int, int, int, int, int );

	void check_iso_depth( FixISOZ *, float *, int, int );
	void check_depth( float, int *, float *, int, int );

	void compute_synthetics( int, int, EventInfo *, Greens **, Solution *, int );
	void write_email_message( FILE *, int, int, Solution *, EventInfo *, Greens **, int );
	void plot_z_vs_fit( int, float *, Solution *, EventInfo *, char * );
	void plotmech( int, Solution *, EventInfo *, char *, float );
	void write_sol_rec( FILE *, int, int, EventInfo *, Solution *, Greens ** );
	void make_gmt_map( int, int, EventInfo *, Solution *, Greens ** );
	void xcorr( float *, float *, int, float, int *, float *, float *, float, int, int );
	void plot_results( int, Solution *, EventInfo * );
	void calc_azi_gap_and_dmin( int, int, EventInfo *, Solution *, Greens ** );
	void write_mterror( FILE *, int, Solution *, EventInfo *, Greens ** );
	void wrtnewsac( char *FO, float dt, int ns, float *ar, float b );
	void Usage_Print();

/********************/
/*** program name ***/
/********************/
	strcpy( progname, av[0] );
	strcpy( output_pathname, "plotmech\0" );
	fprintf( stderr, "%s: version=%s releasee date=%s\n", 
		progname, Version_Label, Version_Date );

	if(verbose) 
	{
	  fprintf( stdout, "%s: version=%s release date=%s\n", 
		progname, Version_Label, Version_Date );
	}

/*************/
/*** USAGE ***/
/*************/
	if( ac <= 1 ) Usage_Print();

/*****************************************************/
/*** get the input parameters foreach each station ***/
/*****************************************************/
	setpar(ac,av);
	mstpar( "par", "s", &evinfo_filename );
	mstpar( "mtdegfree", "d", &mtdegfree );
	mstpar( "ts0", "f", &ts0 );
	mstpar( "fixz", "f", &FixMyZ );
	mstpar( "Nboot", "d", &Nmodels );

	getpar( "outputpath", "s", output_pathname );
	getpar( "verbose", "b", &verbose );
	getpar( "norm", "b", &Distance_Normalize );
	getpar( "shift", "b", &ishift );
	getpar( "ctol", "f", &cortol );
	myfixisoz.z = 0;
	getpar( "FixISOZ", "f", &(myfixisoz.z) );
	getpar( "PltXcorLabel", "b", &PltXcorLabel );
	endpar();

	if( myfixisoz.z > 0 )
		myfixisoz.iswitch = 1;
	else
		myfixisoz.iswitch = 0;
	
	if( Distance_Normalize )
	{
	  fprintf( stdout, "%s: Distance_Normalize is ON\n", progname );
	  fprintf( stderr, "%s: Distance_Normalize is ON\n", progname );
	}

	if( myfixisoz.iswitch )
	{
		fprintf( stdout, 
			"%s: FixISOZ z = %g iswitch= %d is ON\n", 
			progname, 
			myfixisoz.z, 
			myfixisoz.iswitch 
		);
	}
	else
	{
		fprintf( stdout, "%s: FixISOZ=%d is OFF\n", 
			progname, myfixisoz.iswitch );
	}

/*******************************************/
/*** make output directory for GMT plots ***/
/*******************************************/
	mk_gmtplot_dir( output_pathname, verbose );

/******************************************/
/*** allocate memory for parameter list ***/
/******************************************/
	if( verbose ) 
		printf( "%s: allocating memory for data and event information\n", 
			progname );

	ev  = (EventInfo *)malloc(sizeof(EventInfo));
	ev  = (EventInfo *)glib2inv_get_input_parameters( evinfo_filename, ev, &nsta, verbose );

/********************************************/
/*** loop over stations and load the data ***/
/********************************************/
	if( verbose ) printf( "%s: reading data nsta=%d\n", progname, nsta );
	load_the_data( ev, nsta, ts0, verbose );

/******************************/
/*** load green's functions ***/
/******************************/

	if(verbose) 
	{
	   printf( "%s: allocating memory for Green's function\n",
		progname );
	}
	grn = (Greens **)malloc( nsta*sizeof(Greens *) );
	z = (float *)load_greens( ev, grn, nsta, &nz, verbose );

/*************************************/
/*** FixISOZ check depth set index ***/
/*************************************/
	
	if( myfixisoz.iswitch )
	{
		check_iso_depth( &myfixisoz, z, nz, verbose );
	}

/**************************************/
/*** check if fixing solution depth ***/
/*** iz_best get reset below        ***/
/**************************************/

	if( FixMyZ != -99 )
	{
		check_depth( FixMyZ, &FixMyiz, z, nz, verbose );
	}

/*****************************************************/
/*** Error check if any any stations are turned on ***/
/*****************************************************/

	check_on_status_ok = 0;
	for( ista=0; ista<nsta; ista++ )
	{
		if( ev[ista].iused == 1 ) check_on_status_ok=1;
	}
	if( !check_on_status_ok )
	{
		fprintf( stderr, 
		  "%s: ERROR! no stations turned on in the par file %s\n",
			progname, evinfo_filename );
		exit(-1);
	}


/*********************************/
/*** set the type of inversion ***/
/*********************************/

	sol = (Solution *)malloc(nz*sizeof(Solution));
	for( iz=0; iz<nz; iz++ )
	{
		if( mtdegfree == 1 )  sol[iz].mt_type = EXPLOSION;
		if( mtdegfree == 5 )  sol[iz].mt_type = DEVIATORIC;
		if( mtdegfree == 6 )  sol[iz].mt_type = FULL_MT;
	}

	if( verbose ) printf("%s: calling invert()\n", progname );

	iz = 0;
	nres = size_A_matrix( ev, grn, nsta, iz );
	res = calloc( nres, sizeof(float) );
	best_b_vector = calloc( nres+1, sizeof(float) );

	invert0( ev, grn, nsta, nz, FixMyiz, sol, res, best_b_vector, &nres, verbose, 
		mtdegfree, Distance_Normalize, myfixisoz, output_pathname );

	wrtnewsac( "res.sac", 1.0, nres, res, 0.0 );
	wrtnewsac( "best_b_vector.sac", 1.0, nres, best_b_vector, 0.0 );

/****************************/
/*** what is the best fit ***/
/****************************/
	if( FixMyZ != -99 )
	{
		iz_best = FixMyiz;
	} 
	else
	{
		iz_best = 0;
		bestfit = sol[0].total_fitness1;
		for( iz=0; iz<nz; iz++ )
		{
			if( sol[iz].total_fitness1 > bestfit ) 
			{
				bestfit = sol[iz].total_fitness1;
				iz_best = iz;
			}
		}
	}

/******************************************************************/
/*** write out a gmt shell script for each time shift and depth ***/
/******************************************************************/

	mechanism_size = 0.4;
	plotmech( iz_best, sol, ev, output_pathname, mechanism_size );

/********************************************/
/*** write an output file with the errors ***/
/********************************************/
	sprintf( asc_file_name, "mterror.out" );
	if( (fpasc=fopen( asc_file_name, "w" )) == NULL )
		fprintf( stderr, "cannot open file %s for writting\n", asc_file_name );
	write_mterror( fpasc, nz, sol, ev, grn );
	fclose(fpasc);
	
/********************************************/
/*** make an ascii plot for fast email    ***/
/********************************************/
	calc_azi_gap_and_dmin( iz_best, nsta, ev, sol, grn );
	sprintf( asc_file_name, "email_T%05.1fsec_Z%05.1fkm_.txt", 
			sol[iz_best].ot, grn[0][iz_best].evdp );
	if(verbose)
		fprintf(stdout, "Writing Email Messages to %s\n", asc_file_name );
	if( (fpasc=fopen( asc_file_name, "w" ) ) == NULL )
		fprintf(stderr, "cannot open file for writting\n");
	write_email_message( fpasc, nsta, iz_best, sol, ev, grn, forward );
	fclose(fpasc);

/*************************************/
/*** write out a gmt shell script  ***/
/*************************************/

	if(verbose)
		fprintf( stdout, "bestfit=%g iz=%d\n", bestfit, iz_best );	
	sprintf( asc_file_name, "results.%d.out", mtdegfree );

	if( (fpasc=fopen( asc_file_name, "a" ) ) == NULL )
		fprintf(stderr, "cannot open file for writting\n");

	write_sol_rec( fpasc, iz_best, nsta, ev, sol, grn );
	fclose(fpasc);

/*************************************/
/*** write out a gmt shell script ***/
/*************************************/
	plot_z_vs_fit( iz_best, z, sol, ev, output_pathname );

/***************************************/
/*** compute synthetics for plotting ***/
/***************************************/

	if(verbose)
	{
	  fprintf( stdout, "%s: recalculate the synthetics for iz_best=%d\n",
		progname, iz_best );
	}

	for( ista=0; ista<nsta; ista++ )
	{
	  ev[ista].syn_r.data = calloc( ev[ista].nt, sizeof(float) );
	  ev[ista].syn_z.data = calloc( ev[ista].nt, sizeof(float) );
	  ev[ista].syn_t.data = calloc( ev[ista].nt, sizeof(float) );

	  if( verbose )
	  {
	    printf( "calling compute_synthetics iz_best=%d ista=%d nt=%d dt=%g\n",
		iz_best, ista, ev[ista].nt, ev[ista].dt );
	  }

	  if(verbose)
	  {
	    printf( "calling compute_synthetics iz_best=%d ista=%d nt=%d dt=%g\n",
                  iz_best, ista, ev[ista].nt, ev[ista].dt );
	  }
	  compute_synthetics( ista, iz_best, ev, grn, sol, mtdegfree );
	}

/*******************************************************************************************/
/*** for each station do a cross correlation to find the lag time and correlation values ***/
/*******************************************************************************************/

	if(verbose)
	{
	  fprintf( stderr, "%s: cross correlatio for iz_best=%d cortol=%f ishift=%d\n", 
		progname, iz_best, cortol, ishift );
	}

	for( ista=0; ista<nsta; ista++ )
	{
	  xcorr( &(ev[ista].z.data[0]), &(ev[ista].syn_z.data[0]), ev[ista].nt, ev[ista].dt, 
	    &(ev[ista].izlag), &(ev[ista].ztlag), &(ev[ista].zxcor), cortol, verbose, ishift );

	  xcorr( &(ev[ista].ns.data[0]), &(ev[ista].syn_r.data[0]), ev[ista].nt, ev[ista].dt,
	    &(ev[ista].irlag), &(ev[ista].rtlag), &(ev[ista].rxcor), cortol, verbose, ishift );

	  xcorr( &(ev[ista].ew.data[0]), &(ev[ista].syn_t.data[0]), ev[ista].nt, ev[ista].dt,
	    &(ev[ista].itlag), &(ev[ista].ttlag), &(ev[ista].txcor), cortol, verbose, ishift );
	}

/*************************************/
/*** Cgraphics PS library routines ***/
/*************************************/

	sprintf( ps_plot_filename, "plot_T%05.1fsec_Z%05.1fkm_", 
		sol[iz_best].ot, grn[0][iz_best].evdp );

	psplot( nsta, iz_best, ps_plot_filename, ev, sol, grn, 0, verbose, 
		forward, PltXcorLabel, LANDSCAPE );

	plot_results( iz_best, sol, ev );

	free(sol);

/*************************************/
/*** bootstrap resample simulation ***/
/*************************************/

	sol = (Solution *)malloc(nz*sizeof(Solution));
        for( iz=0; iz<nz; iz++ )
        {
           if( mtdegfree == 1 )  sol[iz].mt_type = EXPLOSION;
           if( mtdegfree == 5 )  sol[iz].mt_type = DEVIATORIC;
           if( mtdegfree == 6 )  sol[iz].mt_type = FULL_MT;
        }

        if( verbose ) printf("%s: calling invert_sim()\n", progname );

        invert_sim( ev, grn, nsta, iz_best, sol, res, best_b_vector, verbose, mtdegfree, 
		Distance_Normalize, myfixisoz, Nmodels, output_pathname );

/*****************************/
/*** unallocate the memory ***/
/*****************************/
	if(verbose) fprintf(stderr, "%s: Trying to free memory...", progname );
	free(sol);
	free(z);
	for( ista=0; ista<nsta; ista++ )
	{
		free( ev[ista].ew.data );
		free( ev[ista].ns.data );
		free( ev[ista].z.data );

		free( ev[ista].syn_t.data );
		free( ev[ista].syn_r.data );
		free( ev[ista].syn_z.data );
	}
	free(ev);
	free(grn);
	free(res);
	free(best_b_vector);
	if(verbose)
	{
	  fprintf(stderr, " Done.\n" );
	  fprintf(stderr, "%s: Program finished.  Bye-Bye!\n", progname );
	}
	exit(0);

} /*** end of mtinv.c ***/



/*******************************************************/
/*** this subroutine does the inversion by looping   ***/
/*** over all the greens functions in the library    ***/
/*******************************************************/

void invert0( EventInfo *ev, 
	Greens **grn, 
	int nsta, 
	int nz, 
	int iz_best,
	Solution *sol, 
	float *res,
	float *best_b_vector,
	int *nres,
	int verbose, 
	int mtdegfree, 
	int Distance_Normalize,
	FixISOZ myfixisoz, 
	char *output_pathname )
{
	int ista, iz;
	char sac_file_name[128];
	int idumpsac = 0;
	FILE *fp;

/*********************************************************/
/*** cols = 6 colums of symetic moment tensor elements ***/
/*********************************************************/

	int i, j, rows, cols;

	float **a_matrix;   /*** A matrux with dimensions a[1..rows][1..cols] ***/
	float **u_matrix;   /*** temp space               u[1..rows][1..cols] ***/
	float **v_matrix;   /*** temp space               v[1..cols][1..cols] ***/
	float *w_vector;    /*** temp space               w[1..cols]          ***/
	float *b_vector;    /*** data                     b[1..rows]          ***/
	float *s_vector;    /*** synthetic                s[1..rows]          ***/
	float *x_vector;    /*** solution (mom ten)       x[1..cols]          ***/
	float *e_vector;    /*** error vector             e[1..cols]          ***/
	float **cv_matrix;  /*** covariance matrix       cv[1..cols][1..cols] ***/

	float **matrix( int, int, int, int );
	float *vector( int, int );

	int size_A_matrix( EventInfo *, Greens **, int, int );
	void inversion_init_mem( int, int, float **, float **, float *, float *, float *, 
			float **, float **, float *, float * );
	void make_amatrix(Greens **,EventInfo *,int,int,float **,float *,int,int,FixISOZ);
	void matrix_copy( int, int, float **, float ** );
	void vector_copy( int, float *, float * );
	void singular_value_decomposition(int rows, int cols, float **u_matrix, 
		float *w_vector, float **v_matrix, float *b_vector, float *x_vector );

	void matmul( int, float **, int, float *, int, float * );
	void compute_residual(float *b_vector,float *s_vector,int rows,float *res,float fac);
	void wrtnewsac( char *FO, float dt, int ns, float *ar, float b );
	void svdvar( float **, int, float *, float ** );
	
	void fitness( Solution *, int, float *, float *, int, int, int );
	void set_mt_sol( EventInfo *, Solution *, float *, int, int, int );
	void write_gmt_xy_values( char *, Solution *, EventInfo *, Greens **, int, int, int );
	void dumpSAC( EventInfo *, Greens **, int, int, int, float *, int );
	void write_mt_sim( FILE *, int, Solution *, int, int );

/*********************************************************************************************/
/*** LOOP OVER DEPTH *************************************************************************/
/*********************************************************************************************/
	cols = 6;

	for( iz = 0 ; iz < nz ; iz++ )
	{

	/*************************************************/
	/*** get the total data length rows the matrix ***/
	/*************************************************/
		rows = size_A_matrix( ev, grn, nsta, iz );
		if( verbose ) 
		{
		  printf("%s: A matrix: iz=%d rows=%d cols=%d\n", 
			progname, iz, rows, cols);
		}

	/*************************/
	/*** Allocating memory ***/
	/*************************/
		if(verbose)
		{
		 printf("%s: allocating memory for iz=%d\n", progname, iz );
		 fprintf(stdout, "%s: Allocating memory for a_matrix rows=%d cols=%d\n", 
			progname, rows, cols );
		}
		a_matrix  = matrix( 1, rows+1, 1, cols+1 );
		u_matrix  = matrix( 1, rows+1, 1, cols+1 );
		v_matrix  = matrix( 1, cols+1, 1, cols+1 );
		cv_matrix = matrix( 1, cols+1, 1, cols+1 );
		w_vector = vector( 1, cols+1 );
		e_vector = vector( 1, cols+1 );
		x_vector = vector( 1, cols+1 );
		b_vector = vector( 1, rows+1 );
		s_vector = vector( 1, rows+1 );

	/********************************/
	/***** initialize memory ********/
	/********************************/
	
		inversion_init_mem( rows, cols, a_matrix, u_matrix, w_vector, e_vector,
			x_vector, cv_matrix, v_matrix, b_vector, s_vector );	

	/*********************************************************/
	/*** set up the A matrix and data vector for inversion ***/
	/*********************************************************/

		make_amatrix( grn, ev, nsta, iz, a_matrix, b_vector, mtdegfree, 
			Distance_Normalize, myfixisoz );

	/***************************************/
	/*** copy A matrix into the U matrix ***/
	/***************************************/

		matrix_copy( rows, cols, u_matrix, a_matrix );

	/******************************/
	/***** do the inversion *******/
	/******************************/
		if( verbose )
		{
		  printf("%s: inverting... calling svdcmp() rows=%d cols=%d\n", 
			progname, rows, cols );
		}

		singular_value_decomposition( rows, cols, u_matrix, w_vector, 
			v_matrix, b_vector, x_vector );

		matmul( 0, a_matrix, cols, x_vector, rows, s_vector );
		fitness( sol, iz, b_vector, s_vector, rows, mtdegfree, verbose );
		set_mt_sol( ev, sol, x_vector, iz, mtdegfree, verbose );

		if( iz == iz_best )
		{
		  *nres = rows;
		  vector_copy( rows, best_b_vector, s_vector );
		  compute_residual( b_vector, s_vector, rows, res, 1.0 );
		  wrtnewsac( "dat.sac", 1.0, rows, b_vector, 0.0);

		  fp = fopen("mtsim.out.orig","w");
		  write_mt_sim( fp, 0, sol, iz_best, verbose );
		  fclose(fp);
		}

	/************************************************************/
	/*** calculate the covariance matrix default is sigma = 1 ***/
	/*** get sigma from RMS preevent noise ? level            ***/
	/*** error is 1.96 * sqrt( diag(CV_matrix) )              ***/
	/************************************************************/

		/* svdvar( v_matrix, cols, w_vector, cv_matrix ); */

		if(idumpsac)
		  dumpSAC( ev, grn, nsta, iz, rows, s_vector, verbose );

		sol[iz].evlo = ev[0].evlo;
		sol[iz].evla = ev[0].evla;
		sol[iz].evdp = ev[0].evdp;
		sol[iz].ot   = ev[0].ot_shift;

	/******************************************************************/
	/*** write the output to GMT files for plotting in plotmech.csh ***/
	/******************************************************************/

		write_gmt_xy_values( output_pathname, sol, ev, grn, iz, nsta, verbose );
		
	/****************************/
	/*** free memory clean up ***/
	/****************************/
		if( verbose ) 
		{
		  printf("%s: freeing memory inside invert\n\trows=%d\n\tcols=%d\n\n", 
				progname, rows, cols );
		  printf( "%s: freeing memory for a_matrix\n", progname); free_matrix( a_matrix, 1, rows+1, 1, cols+1 );
		  printf( "%s: freeing memory for u_matrix\n", progname); free_matrix( u_matrix, 1, rows+1, 1, cols+1 );
		  printf( "%s: freeing memory for v_matrix\n", progname); free_matrix( v_matrix, 1, cols+1, 1, cols+1 );
		  printf( "%s: freeing memory for cv_matrix\n", progname);free_matrix( cv_matrix, 1, cols+1, 1, cols+1 );
		  printf( "%s: freeing memory for x_vector\n", progname); free_vector( x_vector, 1, cols+1 );
                  printf( "%s: freeing memory for s_vector\n", progname); free_vector( s_vector, 1, rows+1 );
		  printf( "%s: freeing memory for w_vector\n", progname); free_vector( w_vector, 1, cols+1 );
		  printf( "%s: freeing memory for b_vector\n", progname); free_vector( b_vector, 1, rows+1 );
		  printf( "%s: freeing memory for e_vector\n", progname); free_vector( e_vector, 1, cols+1 );
		}

	}  /*** iz ***/

	if(verbose)
	{
	 printf("%s: Exiting from invert()\n", progname );
	 fflush(stdout);
	}

} /*** END OF INVERT0() ***/


/***********************************************/
/*** INVERT_SIM()                            ***/
/***********************************************/

void invert_sim( EventInfo *ev, 
		Greens **grn, 
		int nsta, 
		int iz_best, 
		Solution *sol,
		float *res,
		float *best_b_vector,
		int verbose,
		int mtdegfree,
		int Distance_Normalize,
		FixISOZ myfixisoz,
		int Nmodels, 
		char *output_pathname )
{
	int ista, iz;
	int k;
	char sac_file_name[128];
	FILE *fp;
	/* Solution *newsol; */

	int i, j, rows, cols;
	float **a_matrix;   /*** A matrux with dimensions a[1..rows][1..cols] ***/
	float **u_matrix;   /*** temp space               u[1..rows][1..cols] ***/
	float **v_matrix;   /*** temp space               v[1..cols][1..cols] ***/
	float *w_vector;    /*** temp space               w[1..cols]          ***/
	float *b_vector;    /*** data                     b[1..rows]          ***/
	float *s_vector;    /*** synthetic                s[1..rows]          ***/
	float *x_vector;    /*** solution (mom ten)       x[1..cols]          ***/
	float *e_vector;    /*** error vector             e[1..cols]          ***/
	float **cv_matrix;  /*** covariance matrix       cv[1..cols][1..cols] ***/

	float **matrix( int, int, int, int );
	float *vector( int, int );

	int size_A_matrix( EventInfo *, Greens **, int, int );
        void inversion_init_mem( int, int, float **, float **, float *, float *, float *,
                        float **, float **, float *, float * );
        void make_amatrix(Greens **,EventInfo *,int,int,float **,float *,int,int,FixISOZ);
        void matrix_copy( int, int, float **, float ** );
        void vector_copy( int, float *, float * );
        void singular_value_decomposition( int rows, int cols, float **u_matrix, 
		float *w_vector, float **v_matrix, float *b_vector, float *x_vector );

        void matmul( int, float **, int, float *, int, float * );
        void compute_residual(float *b_vector,float *s_vector,int rows,float *res,float fac);
        void wrtnewsac( char *FO, float dt, int ns, float *ar, float b );
        void svdvar( float **, int, float *, float ** );

        void fitness( Solution *, int, float *, float *, int, int, int );
        void set_mt_sol( EventInfo *, Solution *, float *, int, int, int );
        void write_gmt_xy_values( char *, Solution *, EventInfo *, Greens **, int, int, int );
        void dumpSAC( EventInfo *, Greens **, int, int, int, float *, int );

        void write_mt_sim( FILE *, int, Solution *, int, int );
	void BS_replace( float *, int, float *, int, float *, int, int );

/*************************************************************/
/*** set the iz to the iz_best passed to invert_sim via nz ***/
/*************************************************************/

	iz = iz_best;

/*************************************************/
/*** get the total data length rows the matrix ***/
/*************************************************/

	cols = 6;
	rows = size_A_matrix( ev, grn, nsta, iz_best );

	if(verbose) 
	{
	  fprintf( stdout, "%s: invert_sim(): A matrix: rows=%d cols=%d\n", 
		progname, rows, cols);
	}

/*************************/
/*** Allocating memory ***/
/*************************/
	if(verbose) 
	{
	  printf("%s: allocating memory for iz=%d\n", progname, iz_best );
	  fprintf(stdout, "%s: Allocating memory for a_matrix rows=%d cols=%d\n", 
		progname, rows, cols );
	}

	a_matrix  = matrix( 1, rows+1, 1, cols+1 );
	u_matrix  = matrix( 1, rows+1, 1, cols+1 );
	v_matrix  = matrix( 1, cols+1, 1, cols+1 );
	cv_matrix = matrix( 1, cols+1, 1, cols+1 );
	w_vector = vector( 1, cols+1 );
	e_vector = vector( 1, cols+1 );
	x_vector = vector( 1, cols+1 );
	b_vector = vector( 1, rows+1 );
	s_vector = vector( 1, rows+1 );

	fp = fopen( "mtsim.out", "w" );

	for( k = 0; k < Nmodels; k++ )
	{

	/*** clean out solution ***/
	/*****
	  newsol = calloc((2*(iz+1)), sizeof(Solution) );
	  if( mtdegfree == 1 ) newsol[iz].mt_type = EXPLOSION;
	  if( mtdegfree == 5 ) newsol[iz].mt_type = DEVIATORIC;
	  if( mtdegfree == 6 ) newsol[iz].mt_type = FULL_MT;
	  newsol[iz].evlo = ev[0].evlo;
	  newsol[iz].evla = ev[0].evla;
	  newsol[iz].evdp = ev[0].evdp;
	  newsol[iz].ot   = ev[0].ot_shift;
	****/
	  sol[iz].mt_type = FULL_MT;
	  sol[iz].evlo = ev[0].evlo;
	  sol[iz].evla = ev[0].evla;
	  sol[iz].evdp = ev[0].evdp;
	  sol[iz].ot   = ev[0].ot_shift;

	  inversion_init_mem( rows, cols, a_matrix, u_matrix, w_vector, e_vector,
                        x_vector, cv_matrix, v_matrix, b_vector, s_vector );

	  make_amatrix( grn, ev, nsta, iz_best, a_matrix, b_vector, mtdegfree, 
		Distance_Normalize, myfixisoz );

	  BS_replace( res, rows, best_b_vector, rows, b_vector, k, verbose );

	  matrix_copy( rows, cols, u_matrix, a_matrix );

	  singular_value_decomposition( rows, cols, u_matrix, w_vector, 
		v_matrix, b_vector, x_vector );

	  matmul( 0, a_matrix, cols, x_vector, rows, s_vector );

	  /*** sprintf( sacfilename, "dat.%05d.sac", k ); ***/
	  /*** wrtnewsac( sacfilename, 1.0, rows, b_vector, 0.0 ); ***/

	  fitness( sol, iz_best, b_vector, s_vector, rows, mtdegfree, verbose );

	  set_mt_sol( ev, sol, x_vector, iz_best, mtdegfree, verbose );
	
	  write_mt_sim( fp, k, sol, iz_best, verbose );

	  /*** free(newsol); ***/

	} /*** loop over Nmodels bootstrap resamples ***/

/****************************/
/*** free memory clean up ***/
/****************************/
	if(verbose)
	{ 
	  fprintf( stdout, "%s: freeing memory inside invert\n\trows=%d\n\tcols=%d\n\n",
		progname, rows, cols );
	  fprintf(stdout, "%s: freemem a_matrix\n", progname);free_matrix( a_matrix, 1, rows+1, 1, cols+1 );
	  fprintf(stdout, "%s: freemem u_matrix\n", progname);free_matrix( u_matrix, 1, rows+1, 1, cols+1 );
          fprintf(stdout, "%s: freemem v_matrix\n", progname);free_matrix( v_matrix, 1, cols+1, 1, cols+1 );
          fprintf(stdout, "%s: freemem cv_matrix\n",progname);free_matrix( cv_matrix, 1, cols+1, 1, cols+1 );
          fprintf(stdout, "%s: freemem x_vector\n", progname);free_vector( x_vector, 1, cols+1 );
          fprintf(stdout, "%s: freemem s_vector\n", progname);free_vector( s_vector, 1, rows+1 );
          fprintf(stdout, "%s: freemem w_vector\n", progname);free_vector( w_vector, 1, cols+1 );
          fprintf(stdout, "%s: freemem b_vector\n", progname);free_vector( b_vector, 1, rows+1 );
          fprintf(stdout, "%s: freemem e_vector\n", progname);free_vector( e_vector, 1, cols+1 );
	  fprintf( stdout, "%s: Exiting from invert()\n", progname );
	  fflush( stdout );
	}

}  /*** END OF INVERT_SIM() ***/


/********************************************************************************************/
/*** subroutine write_mt_sim() ***/
/********************************************************************************************/

void write_mt_sim( FILE *fp, int k, Solution *sol, int iz, int verbose )
{
	/*** k  eps   kiso  ffac   Mw   PDC   PCLVD PISO  VRED   S1    D1    R1   S2    D2     R2 ***/
	fprintf( fp, 
	  "%05d %6.3f %6.3f %8.2f %5.2f %3.0f %3.0f %3.0f %6.2f %3.0f %2.0f %4.0f %3.0f %2.0f %4.0f\n",
		k,
		sol[iz].epsilon,
		sol[iz].k,
		sol[iz].f_factor,
		sol[iz].mw,
		sol[iz].PDC,
		sol[iz].PCLVD,
		sol[iz].PISO,
		sol[iz].var_red,
		sol[iz].stk0,
		sol[iz].dip0,
		sol[iz].rak0,
		sol[iz].stk1,
		sol[iz].dip1,
		sol[iz].rak1 );

} /*** END OF WRITE_MT_SIM() ***/


void vector_copy( int rows, float *out, float *in )
{
	int i;
	for( i = 0; i <= rows; i++ ) out[i] = in[i];

} /*** VECTOR_COPY() ***/


/********************************************************************************************/
/*** subroutine matrix_copy() ***/
/********************************************************************************************/

void matrix_copy( int rows, int cols, float **out, float **in )
{
	int i, j;
	for( j = 1; j <= cols; j++ )
	{
		for( i = 1; i <= rows; i++ )
		{
			out[i][j] = in[i][j];
		}
	}

} /*** MATRIX_COPY() ***/



/********************************************************************************************/
/*** subroutine inversion_init_mem() ***/
/********************************************************************************************/

void inversion_init_mem( int rows, int cols,
			float **a_matrix,
			float **u_matrix,
			float *w_vector,
			float *e_vector,
			float *x_vector,
			float **cv_matrix,
			float **v_matrix,
			float *b_vector,
			float *s_vector )
{
	int i, j;

        for( j=1; j<=cols; j++ )
        {
                for( i=1; i<=rows; i++ )
                {
                        u_matrix[i][j] = 0;
                        a_matrix[i][j] = 0;
                }
                w_vector[j] = 0;
                e_vector[j] = 0;
                x_vector[j] = 0;
        }
        for( j=1; j<=cols; j++ )
        {
                for( i=1; i<=cols; i++ )
                {
                        cv_matrix[i][j] = 0;
                        v_matrix[i][j] = 0;
                }
        }
        for( i=1; i<=rows; i++ )
        {
                b_vector[i] = 0;
                s_vector[i] = 0;
        }

} /*** INVERSION_INIT_MEM() ***/



/********************************************************************************************/
/*** subroutine singular_value_decomposition() ***/
/********************************************************************************************/

void singular_value_decomposition( int rows, int cols,
				float **u_matrix,
				float *w_vector,
				float **v_matrix,
				float *b_vector,
				float *x_vector )
{
	int i, j;
	float wmax, wmin;
	const float tol = 1.0E-05;

	void svdcmp( float **, int, int, float *, float ** );
	void svbksb( float **, float *, float **, int, int, float *, float * );

	svdcmp( u_matrix, rows, cols, w_vector, v_matrix );

/********************************************************************************************/
/*** this is where we set the threshold for singular values allowed to be nonzero.        ***/
/*** The constant is typical but not universal. experiment with values other than 1.0E-06 ***/
/*** this will be the maximum singular value obtained                                     ***/
/********************************************************************************************/

        wmax = 0;
        for( j=1; j<=cols; j++)
        {
                if( w_vector[j] > wmax) wmax=w_vector[j];
        }
                                                                                                                           
                                                                                                                           
        wmin = wmax * 1.0E-5;
        for( j=1; j<=cols; j++)
        {
                if( w_vector[j] < wmin ) w_vector[j]=0.0;
        }
 
	svbksb( u_matrix, w_vector, v_matrix, rows, cols, b_vector, x_vector);

} /*** END SINGULAR_VALUE_DECOMPOSITION() ***/



/********************************************************************************************/
/*** subroutine size_A_matrix() ***/
/********************************************************************************************/


int size_A_matrix( EventInfo *ev, Greens **grn, int nsta, int iz )
{
	int rows = 1;
	int ista;
	for( ista = 0; ista < nsta; ista++ )
	{
		if( ev[ista].iused == 1 )
		{
			rows += 3 * grn[ista][iz].nt;
		}
	}
	return rows;

}  /*** END SIZE_A_MATRIX() ***/


/********************************************************************************************/
/*** subroutine  set_mt_sol( ) ***/
/********************************************************************************************/

void set_mt_sol( EventInfo *ev, Solution *sol, float *x_vector, int iz, int mtdegfree, int verbose )
{
	MomentTensor Ma, Mn;

	void set_moment_tensor( MomentTensor *, MomentTensor *, float *, int, int );
	void normalize_moment_tensor( MomentTensor *, MomentTensor *, int );
	void mt2eig( MomentTensor, Solution *, int, int );
	void eig2iso( EventInfo *, Solution *, int, int );
	void Eig2MajorDC( Solution *, int, int );
	void Eig2MinorDC( Solution *, int, int );
	
	sol[iz].moment_tensor[1][1] = x_vector[1]; /* Mxx */
        sol[iz].moment_tensor[2][2] = x_vector[2]; /* Myy */
        sol[iz].moment_tensor[1][2] = x_vector[3]; /* Mxy */
        sol[iz].moment_tensor[1][3] = x_vector[4]; /* Mxz */
        sol[iz].moment_tensor[2][3] = x_vector[5]; /* Myz */
        sol[iz].moment_tensor[3][3] = x_vector[6]; /* Mzz */
        sol[iz].moment_tensor[2][1] = x_vector[3]; /* Myx */
        sol[iz].moment_tensor[3][1] = x_vector[4]; /* Mzx */
        sol[iz].moment_tensor[3][2] = x_vector[5]; /* Mzy */

	if( mtdegfree == 5 )
		sol[iz].moment_tensor[3][3] = -(x_vector[1] + x_vector[2]);

	if(verbose)
	  printf("Normalizing the seismic moment tensor\n" );

	set_moment_tensor( &Ma, &Mn, x_vector, mtdegfree, verbose );

	normalize_moment_tensor( &Ma, &Mn, verbose );

        sol[iz].dmoment  = Ma.moment;
        sol[iz].mw       = Ma.Mw;
        sol[iz].exponent = Ma.expon;
        sol[iz].abcassa  = Ma.abcassa;
                                                                                                                           
        sol[iz].mrr = Mn.rr;
        sol[iz].mtt = Mn.tt;
        sol[iz].mff = Mn.ff;
        sol[iz].mrt = Mn.rt;
        sol[iz].mrf = Mn.rf;
        sol[iz].mtf = Mn.tf;
                                                                                                                           
        sol[iz].mxx = Mn.xx;
        sol[iz].mxy = Mn.xy;
        sol[iz].mxz = Mn.xz;
        sol[iz].myy = Mn.yy;
        sol[iz].myz = Mn.yz;
        sol[iz].mzz = Mn.zz;

/************************************************************************/
/*** eigenvalue analysis on moment tensor to get PDC and str/dip/rak  ***/
/*** for both nodal planes and T- P- and N-axis.  Clone moment tensor ***/
/*** so not to change the values by the next two routines.  Find      ***/
/*** eigenvalues and eigenvectors by decomposing Mij using eigenvalue ***/
/*** analysis                                                         ***/
/************************************************************************/
        mt2eig( Mn, sol, iz, verbose );
        eig2iso( ev, sol, iz, verbose );
        Eig2MajorDC( sol, iz, verbose );
        Eig2MinorDC( sol, iz, verbose );

} /*** SET_MT_SOLUTION ***/



/********************************************************************************************/
/*** subroutine  fitness()   ***/
/********************************************************************************************/

void fitness( Solution *sol, int iz, float *b_vector, float *s_vector, int rows, 
	int mtdegfree, int verbose )
{
	float variance_reduction( float *, float *, int );
	float compute_l2norm_error( float *, float *, int );

	extern char progname[128];

	sol[iz].var_red = variance_reduction( b_vector, s_vector, rows );

	if(verbose) 
	{
	  printf( "%s: iz=%d %%VRED=%g\n",
              progname, iz, sol[iz].var_red );
	}

	sol[iz].l2norm_error = compute_l2norm_error( b_vector, s_vector, rows );

	if(verbose)
	{
	   printf( "%s: iz=%d %%L2NORM=%g\n",
             progname, iz,  sol[iz].l2norm_error );
	}

	sol[iz].total_fitness1 = 0;
	sol[iz].total_fitness2 = 0;

	if( mtdegfree == 1 || mtdegfree == 6 )
        {
                sol[iz].total_fitness1 = sol[iz].var_red;
                sol[iz].total_fitness2 = sol[iz].var_red;
        }
        else if( mtdegfree == 5 )
        {
           sol[iz].total_fitness1 =
                sol[iz].var_red / ( 101.0 - sol[iz].PDC );
                                                                                                                           
                                                                                                                   
           sol[iz].total_fitness2 =
                18 + sol[iz].var_red / ( 9 + (100-sol[iz].PDC) );
                                                                                                                           
                                                                                                                   
          if( sol[iz].total_fitness2 > 35 ) sol[iz].total_fitness2 = 35;
          if( sol[iz].total_fitness2 < 18 ) sol[iz].total_fitness2 = 18;
        }

} /*** END FITNESS() ***/



/********************************************************************************************/
/*** subroutine  compute_residual()   ***/
/********************************************************************************************/

void compute_residual( float *b_vector, float *s_vector, int rows, float *res_vector, float fac )
{
	int i;
	for( i = 1; i <= rows; i++ )
	{
		res_vector[i] = ( b_vector[i] - s_vector[i] );
	}

} /*** END COMPUTE_RESIDUAL() ***/


/********************************************************************************************/
/*** subroutine  dumpSAC()   ***/
/********************************************************************************************/

void dumpSAC( EventInfo *ev, Greens **grn, int nsta, int iz, int rows, float *s_vector, int verbose )
{
	int ista;
	char sac_file_name[128];
	
	void write_sac_file( char *, Sac_File *, int );
	void demultiplex( Greens **, EventInfo *, int, float *, int, int );
	void sac_minmax( float *, int, float *, float *, float * );
	
	for( ista=0; ista<nsta; ista++ )
	{
		grn[ista][iz].tra = calloc( grn[ista][iz].nt, sizeof(float) );
                grn[ista][iz].rad = calloc( grn[ista][iz].nt, sizeof(float) );
                grn[ista][iz].ver = calloc( grn[ista][iz].nt, sizeof(float) );
                ev[ista].syn_r.data = calloc( ev[ista].ns.s.npts, sizeof(float) );
                ev[ista].syn_t.data = calloc( ev[ista].ew.s.npts, sizeof(float) );
                ev[ista].syn_z.data = calloc( ev[ista].z.s.npts,  sizeof(float) );
	}

	if(verbose) 
		printf("%s: calling demultiplex\n", progname );

        demultiplex( grn, ev, iz, s_vector, rows, nsta );

	for( ista=0; ista<nsta; ista++ )
	{

       /*** SYN radial component ***/
          sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.r.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          ev[ista].syn_r.s = ev[ista].ns.s;
          sac_minmax( ev[ista].syn_r.data, ev[ista].syn_r.s.npts,
                &(ev[ista].syn_r.s.depmax), &(ev[ista].syn_r.s.depmin),
                &(ev[ista].syn_r.s.depmen) );
          write_sac_file( sac_file_name, &(ev[ista].syn_r), verbose );

        /*** SYN vertical component ***/
          sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.z.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          ev[ista].syn_z.s = ev[ista].z.s;
          sac_minmax( ev[ista].syn_z.data, ev[ista].syn_z.s.npts,
                &(ev[ista].syn_z.s.depmax), &(ev[ista].syn_z.s.depmin),
                &(ev[ista].syn_z.s.depmen) );
          write_sac_file( sac_file_name, &(ev[ista].syn_z), verbose );

        /*** SYN transverse component ***/
          sprintf( sac_file_name, "%s.%s.%02d.%02d.syn.t.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          ev[ista].syn_t.s = ev[ista].ew.s;
          sac_minmax( ev[ista].syn_t.data, ev[ista].syn_t.s.npts,
                &(ev[ista].syn_t.s.depmax), &(ev[ista].syn_t.s.depmin),
                &(ev[ista].syn_t.s.depmen) );
          write_sac_file( sac_file_name, &(ev[ista].syn_t), verbose );

        /*** r,z,t data ***/
          sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.r.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          write_sac_file( sac_file_name, &(ev[ista].ns), verbose );
                                                                                                                                                                 
          sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.z.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          write_sac_file( sac_file_name, &(ev[ista].z), verbose );
                                                                                                                                                                 
          sprintf( sac_file_name, "%s.%s.%02d.%02d.dat.t.sac",
                ev[ista].stnm, ev[ista].net, iz, ista );
          write_sac_file( sac_file_name, &(ev[ista].ew), verbose );
	}

	for( ista=0; ista<nsta; ista++ )
	{
          free( ev[ista].syn_r.data );
          free( ev[ista].syn_r.data );
          free( ev[ista].syn_r.data );
          free( grn[ista][iz].rad );
          free( grn[ista][iz].tra );
          free( grn[ista][iz].ver );
	}

} /*** END DUMPSAC()  ***/

void Usage_Print()
{
        fprintf( stderr, "\nUSAGE: %s par= mtdegfree=(1,5,6)\n", progname );
        fprintf( stderr, "\t ts0=[0] fixz=[-99] [no]norm [no]shift ctol=[1] FixISOZ=[-99]\n" );

        fprintf( stderr, "\nREQUIRED PARAMETERS:\n" );
        fprintf( stderr, "\t par=(glib2inv.par) station parameter file\n" );
        fprintf( stderr, "\t mtdegfree=(1,5,6) 1=Isotropic MT, 5=Deviatoric MT, 6=Full MT\n" );

        fprintf( stderr, "\n OPTIONAL PARAMETERSL [DEFAULTS]\n" );
        fprintf( stderr, "\t outputpath=[./plotmech] Output Directory for GMT plots of all solutions\n" );
        fprintf( stderr, "\t ts0=[0]       Origin Time Shift Default is [0]\n" );
        fprintf( stderr, "\t fixz=[-99]    fix the depth Default is [-99] which turns off option\n" );
        fprintf( stderr, "\t [no]verbose   give verbose print to stdout. Default is off.\n" );
        fprintf( stderr, "\t [no]norm     distance normalization default is off\n" );
        fprintf( stderr, "\t [no]shift    shift the data automatically by cross correlation peak. default is off\n" );
        fprintf( stderr, "\t ctol=[0..1]  Correlation coefficient tolerance to shift the data when coef > ctol. defaut is off\n" );
        fprintf( stderr, "\t FixISOZ=     fix the depth of the rex and zex Green's function.  Default is off\n" );
        fprintf( stderr, "\t [no]WgtCovarResid  Weight the covariance matrix by the residual variance [Default is off]\n" );
        fprintf( stderr, 
  "\t [no]PltXcorLabel  Plot the time lag shift and cross correlation as a label in the PostScript plot [Default is on\n" );
        fprintf( stderr, "\n\n" );
}

/********************************************************************************************/
/*** subroutine  BS_replace()                      ***/
/********************************************************************************************/

void BS_replace( float *res, int rrows, float *best_b_vector, int brows, float *b_vector, 
	int iseed, int verbose )
{
	int i, j;
	float ratio;

	srand(iseed+1);
	ratio = 1/(float)RAND_MAX;
	rand();

	for( i = 0; i < brows; i++ )
	{
	  j = (int)rint( rrows * (ratio * (float) rand() ) );
	  b_vector[i] = best_b_vector[i] + res[j];
	}

} /*** END BS_REPLACE() ***/
